<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⟨ ❦ ⟩ RPGStack - Compêndio de Personagens Ancestrais ⟨ ❦ ⟩</title>
    
    <!-- Google Fonts - Art Nouveau Typography -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Cinzel:wght@400;500;600&family=Dancing+Script:wght@500;600&family=Georgia:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS Variables - Éclat Mystique Art Nouveau Palette */
        :root {
            --gold-primary: #D4AF37;
            --gold-light: #F7E98E;
            --gold-dark: #B8860B;
            --burgundy: #722F37;
            --burgundy-light: #8B4B5C;
            --burgundy-dark: #5A252A;
            --emerald: #355E3B;
            --emerald-light: #4A7C59;
            --emerald-dark: #2A4A30;
            --parchment: #FDF5E6;
            --sepia-base: #F5F5DC;
            --aged-paper: #F0E68C;
            --charcoal: #36454F;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, var(--charcoal) 0%, var(--burgundy) 50%, var(--emerald) 100%);
            min-height: 100vh;
            padding: 20px;
            margin: 0;
            color: var(--parchment);
            line-height: 1.6;
        }

        .container {
            width: 100%;
            max-width: none;
            margin: 0 auto;
            background: rgba(253, 245, 230, 0.98);
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow-x: auto;
            min-height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            color: var(--charcoal);
            position: relative;
        }

        .header {
            background: linear-gradient(135deg, var(--burgundy) 0%, var(--burgundy-dark) 100%);
            color: var(--gold-light);
            padding: 40px 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header-ornament {
            font-family: 'Cinzel', serif;
            font-size: 2.2em;
            color: var(--gold-primary);
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.8em;
            margin-bottom: 15px;
            color: var(--gold-primary);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-weight: 700;
        }

        .header p {
            font-family: 'Dancing Script', cursive;
            opacity: 0.9;
            font-size: 1.3em;
            color: var(--gold-light);
        }

        .version-badge {
            position: absolute;
            top: 20px;
            left: 30px;
            background: var(--burgundy);
            color: var(--gold-light);
            padding: 8px 15px;
            border-radius: 8px;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            font-weight: 600;
            z-index: 10;
            border: 1px solid var(--gold-dark);
        }

        @media (max-width: 768px) {
            .version-badge {
                top: 10px;
                left: 10px;
                font-size: 10px;
                padding: 4px 8px;
            }
        }

        .navigation {
            position: absolute;
            top: 15px;
            right: 20px;
        }

        .nav-link {
            background: rgba(212, 175, 55, 0.2);
            color: var(--gold-light);
            padding: 10px 18px;
            border-radius: 8px;
            text-decoration: none;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
            border: 1px solid var(--gold-dark);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .nav-link:hover {
            background: var(--gold-primary);
            color: var(--charcoal);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
        }

        .server-status {
            position: absolute;
            bottom: 15px;
            right: 20px;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .server-status {
                top: 10px;
                right: 10px;
                padding: 6px 12px;
                font-size: 10px;
            }
        }

        .server-status {
            font-family: 'Cinzel', serif;
            font-weight: 600;
            border: 1px solid var(--emerald-light);
            border-radius: 8px;
        }

        .server-status.online {
            background: var(--emerald);
            color: var(--parchment);
        }

        .server-status.offline {
            background: var(--burgundy-dark);
            color: var(--gold-light);
            border-color: var(--burgundy);
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        @media (max-width: 1024px) {
            .main-content {
                flex-direction: column;
            }
        }

        .form-section {
            background: rgba(245, 245, 220, 0.95);
            padding: 30px;
            border-right: 2px solid var(--gold-dark);
            flex: 0 0 420px;
            min-width: 380px;
            max-width: 500px;
            overflow-y: auto;
            position: relative;
        }

        .form-section::before {
            content: '◊';
            position: absolute;
            top: 20px;
            right: 20px;
            font-family: 'Cinzel', serif;
            color: var(--gold-primary);
            font-size: 1.5em;
            opacity: 0.6;
        }

        @media (max-width: 1024px) {
            .form-section {
                flex: none;
                border-right: none;
                border-bottom: 1px solid #dee2e6;
            }
        }

        @media (max-width: 768px) {
            .form-section {
                padding: 15px;
            }
        }

        .database-section {
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow: hidden;
        }

        @media (max-width: 768px) {
            .database-section {
                padding: 15px;
            }
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-group label {
            display: block;
            margin-bottom: 10px;
            font-family: 'Cinzel', serif;
            font-weight: 600;
            color: var(--burgundy);
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 14px;
            border: 2px solid var(--gold-dark);
            border-radius: 8px;
            font-family: 'Georgia', serif;
            font-size: 14px;
            background: rgba(253, 245, 230, 0.9);
            color: var(--charcoal);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--gold-primary);
            box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.2);
            background: var(--parchment);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }

        .sprite-file-container {
            border: 2px dashed var(--gold-dark);
            border-radius: 10px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(253, 245, 230, 0.7);
        }

        .sprite-file-container:hover {
            border-color: var(--gold-primary);
            background: rgba(212, 175, 55, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.2);
        }

        .sprite-file-container.dragover {
            border-color: #667eea;
            background: #e7f3ff;
        }

        .sprite-file-container.has-upload {
            border-color: #17a2b8;
            background: #e6f3ff;
        }

        .sprite-file-container.uploaded {
            border-color: #28a745;
            background: #f8fff9;
        }

        .image-preview {
            max-width: 64px;
            max-height: 64px;
            border-radius: 8px;
            margin: 10px auto;
            display: none;
            image-rendering: pixelated;
            border: 2px solid #dee2e6;
        }

        .sprite-preview {
            display: none;
            margin: 10px auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 2px solid #dee2e6;
            font-family: monospace;
            color: #495057;
            font-size: 12px;
        }

        .sprite-preview.show {
            display: block;
        }

        .file-icon {
            font-size: 24px;
            color: #667eea;
            margin-bottom: 10px;
        }

        .file-text {
            color: #6c757d;
            font-size: 14px;
        }

        .remove-file-btn {
            background: var(--burgundy);
            color: var(--gold-light);
            border: 1px solid var(--burgundy-dark);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            font-weight: 600;
            margin-top: 12px;
            display: none;
            transition: all 0.3s ease;
        }

        .remove-file-btn:hover {
            background: var(--burgundy-dark);
            transform: translateY(-1px);
        }

        .btn {
            padding: 14px 28px;
            border: 2px solid var(--gold-dark);
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: none;
            letter-spacing: 0.5px;
            background: linear-gradient(135deg, var(--gold-primary) 0%, var(--gold-dark) 100%);
            color: var(--charcoal);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            .btn {
                padding: 10px 20px;
                font-size: 14px;
                margin: 3px;
            }
        }

        @media (max-width: 480px) {
            .btn {
                padding: 8px 16px;
                font-size: 12px;
                margin: 2px;
            }
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .database-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .search-box {
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            width: 250px;
        }

        .characters-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        /* Layout de Cards para Personagens */
        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            width: 100%;
        }
        
        .character-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .character-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .character-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .character-name {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }
        
        .character-id-card {
            font-family: 'Courier New', monospace;
            background: #e3f2fd;
            color: #1565c0;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .character-id-card:hover {
            background: #bbdefb;
        }
        
        .character-sprite-section {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .character-sprite-card {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
        }
        
        .character-sprite-card img {
            max-width: 50px;
            max-height: 50px;
            object-fit: contain;
        }
        
        .sprite-placeholder {
            font-size: 24px;
        }
        
        .character-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
        }
        
        .stat-item {
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .stat-label {
            font-size: 11px;
            color: #6c757d;
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
        }
        
        .character-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .character-actions .btn {
            font-size: 12px;
            padding: 6px 12px;
        }
        
        /* Responsividade para Cards */
        @media (max-width: 768px) {
            .characters-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .character-card {
                padding: 15px;
            }
            
            .character-stats {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
        }
        
        @media (max-width: 480px) {
            .character-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Estado vazio */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }
        
        .empty-state h3 {
            margin-bottom: 10px;
            color: #495057;
        }

        /* NOVO: Estilos para ID hexadecimal */
        .character-id {
            font-family: 'Courier New', monospace;
            background: #e3f2fd;
            color: #1565c0;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: bold;
            border: 1px solid #bbdefb;
            display: inline-block;
            white-space: nowrap;
            min-width: 80px;
            text-align: center;
        }

        .character-id:hover {
            background: #bbdefb;
            cursor: pointer;
            transform: scale(1.05);
            transition: all 0.2s ease;
        }

        .character-sprite {
            text-align: center;
            width: 80px;
            padding: 8px;
        }

        .character-sprite img {
            max-width: 48px;
            max-height: 48px;
            border-radius: 6px;
            image-rendering: pixelated;
            border: 2px solid #dee2e6;
            background: #f8f9fa;
            transition: transform 0.2s ease;
        }

        .character-sprite img:hover {
            transform: scale(2);
            z-index: 10;
            position: relative;
            border-color: #667eea;
        }

        .sprite-path-text {
            font-size: 10px;
            color: #6c757d;
            margin-top: 2px;
            word-break: break-all;
            font-family: monospace;
        }

        .sprite-error {
            color: #dc3545;
            font-size: 10px;
            font-style: italic;
        }

        .sprite-placeholder {
            width: 48px;
            height: 48px;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #6c757d;
            margin: 0 auto;
        }

        /* Level system CSS removido */

        .ai-type {
            padding: 3px 8px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .ai-aggressive { background: #ffebee; color: #c62828; }
        .ai-passive { background: #e8f5e8; color: #2e7d32; }
        .ai-pack { background: #fff3e0; color: #ef6c00; }
        .ai-ambush { background: #f3e5f5; color: #7b1fa2; }
        .ai-guardian { background: #e3f2fd; color: #1565c0; }
        .ai-caster { background: #fce4ec; color: #ad1457; }
        .ai-tank { background: #efebe9; color: #5d4037; }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 1100;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            max-width: 350px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: #28a745;
        }

        .notification.error {
            background: #dc3545;
        }

        .notification.info {
            background: #17a2b8;
        }

        .drops-container, .skills-container {
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            background: white;
        }

        .drop-item, .skill-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .drop-item input, .skill-item input {
            flex: 1;
            margin: 0;
        }

        .add-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .file-info {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }

        .loading {
            display: none;
            text-align: center;
            color: #667eea;
        }

        .loading.show {
            display: block;
        }

        .auto-save-info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 13px;
            color: #1565c0;
        }

        .auto-save-info strong {
            display: block;
            margin-bottom: 5px;
        }

        /* NOVO: Sistema HEX ID Info */
        .hex-id-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .hex-id-info strong {
            display: block;
            margin-bottom: 5px;
        }

        .hex-example {
            font-family: 'Courier New', monospace;
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 4px;
            margin-top: 5px;
        }

        /* Tooltip para IDs - REMOVIDO */
        .tooltip {
            position: relative;
            cursor: pointer;
        }

        /* Modal para edição de personagens */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            .modal-content {
                padding: 20px;
                width: 95%;
                max-height: 95vh;
                border-radius: 10px;
            }
        }

        @media (max-width: 480px) {
            .modal-content {
                padding: 15px;
                width: 98%;
                border-radius: 8px;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #dee2e6;
        }

        .modal-header h2 {
            color: #2c3e50;
            margin: 0;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
            padding: 5px;
            line-height: 1;
        }

        .close-btn:hover {
            color: #dc3545;
        }

        /* Melhorias para telas muito pequenas */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            .container {
                border-radius: 10px;
                min-height: calc(100vh - 10px);
            }

            .characters-grid {
                grid-template-columns: 1fr;
            }

            .character-id-card {
                font-size: 9px;
                padding: 3px 6px;
            }
        }

        /* Estilos para Tabela (layout original) */
        .table-container {
            flex: 1;
            overflow: auto;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .character-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            min-width: 800px;
        }
        
        .character-table th {
            background: #2c3e50;
            color: white;
            padding: 10px 12px; /* Reduzido de 12px 15px */
            text-align: left;
            font-weight: 600;
            white-space: nowrap;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .character-table td {
            padding: 6px 10px; /* Reduzido de 8px 12px */
            border-bottom: 1px solid #e9ecef;
            white-space: nowrap;
            vertical-align: middle;
        }
        
        .character-table td:nth-child(1) {
            min-width: 100px;
            max-width: 100px;
            overflow: hidden;
        }
        
        /* Otimização de espaço: colunas Nome e Sprite */
        .character-table th:nth-child(2), /* Nome */
        .character-table td:nth-child(2) {
            padding-left: 8px;
            padding-right: 6px;
            max-width: 120px;
        }
        
        .character-table th:nth-child(3), /* Sprite */
        .character-table td:nth-child(3) {
            padding-left: 6px;
            padding-right: 8px;
            max-width: 100px;
            text-align: center;
        }
        
        .character-table tr:hover {
            background: #f8f9fa;
        }
        
        @media (max-width: 768px) {
            .character-table th {
                padding: 8px 12px;
                font-size: 12px;
            }
            
            .character-table td {
                padding: 6px 8px;
                font-size: 12px;
            }
            
            .character-table {
                min-width: 600px;
            }
        }

        /* Scroll personalizado para webkit */
        .characters-container::-webkit-scrollbar,
        .table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .characters-container::-webkit-scrollbar-track,
        .table-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .characters-container::-webkit-scrollbar-thumb,
        .table-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .characters-container::-webkit-scrollbar-thumb:hover,
        .table-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="version-badge">v3.1.0</div>
            <div class="navigation">
                <a href="/" class="nav-link">🏠 Home</a>
                <a href="/characters" class="nav-link">👥 Characters</a>
                <a href="/maps" class="nav-link">🗺️ Maps</a>
            </div>
            <div class="header-ornament">⟨ ❦ ⟩</div>
            <h1>Compêndio de Personagens Ancestrais</h1>
            <p>Sistema de gerenciamento aristocrático com catalogação completa de heróis únicos</p>
            <div class="server-status" id="serverStatus">Verificando...</div>
        </div>

        <div class="main-content">
            <div class="form-section">
                <h2>Cadastrar Novo Personagem</h2>
                
                <div class="hex-id-info">
                    <strong>🔒 Sistema de ID IMUTÁVEL</strong>
                    • IDs existentes: PRESERVADOS (nunca alterados)<br>
                    • Novos personagens: ID hexadecimal único<br>
                    • <strong>GARANTIA:</strong> IDs são permanentes para referências futuras
                </div>

                <div class="auto-save-info">
                    <strong>🚀 Auto-Save Ativo:</strong>
                    • Sprites salvam em: <code>assets/sprites/</code><br>
                    • Dados salvam em: <code>data/characters.json</code><br>
                    • Export automático: <code>exports/character_database.js</code>
                </div>

                <form id="characterForm">
                    <div class="form-group">
                        <label for="name">Nome do Personagem</label>
                        <input type="text" id="name" name="name" required>
                    </div>

                    <div class="form-row">
                        <!-- Level removido do sistema -->
                        <div class="form-group">
                            <label>Sprite do Personagem</label>
                            <div class="sprite-file-container" id="spriteContainer" onclick="triggerImageUpload()">
                                <div class="file-icon" id="fileIcon">🖼️</div>
                                <div class="file-text" id="fileText">
                                    <strong>Clique para fazer upload</strong><br>
                                    ou arraste uma imagem aqui<br>
                                    <small>Auto-save em assets/sprites/</small>
                                </div>
                                <img class="image-preview" id="imagePreview" alt="Preview">
                                <input type="text" id="spriteFilename" name="spriteFilename" 
                                       placeholder="Nome do arquivo (auto-sugerido)" 
                                       style="margin-top: 10px; width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <div class="sprite-preview" id="spritePreview"></div>
                                <div class="file-info" id="fileInfo"></div>
                                <button type="button" class="remove-file-btn" id="removeFileBtn" onclick="clearSpriteFile(event)">Remover</button>
                            </div>
                            <input type="file" id="spriteInput" name="sprite" accept=".png,.jpg,.jpeg,.gif,.webp" style="display: none;" onchange="handleImageUpload(event)">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="hp">HP</label>
                            <input type="number" id="hp" name="hp" min="1" value="100" required>
                        </div>
                        <div class="form-group">
                            <label for="attack">Físico</label>
                            <input type="number" id="attack" name="attack" min="1" value="10" required>
                        </div>
                        <div class="form-group">
                            <label for="ataque_especial">Especial</label>
                            <input type="number" id="ataque_especial" name="ataque_especial" min="1" value="10" required>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="defense">Defesa Física</label>
                            <input type="number" id="defense" name="defense" min="0" value="5" required>
                        </div>
                        <div class="form-group">
                            <label for="defesa_especial">Defesa Especial</label>
                            <input type="number" id="defesa_especial" name="defesa_especial" min="0" value="10" required>
                        </div>
                    </div>


                    <div class="form-group">
                        <label for="classe">Classe</label>
                        <select id="classe" name="classe" required>
                            <option value="">Selecione uma classe...</option>
                            <!-- Classes serão carregadas dinamicamente -->
                        </select>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="cultura">Cultura</label>
                            <select id="cultura" name="cultura">
                                <option value="">Selecione uma cultura...</option>
                                <option value="Romana">🏛️ Romana</option>
                                <option value="Chinesa">🐲 Chinesa</option>
                                <option value="Eslava">⚔️ Eslava</option>
                                <option value="Grega Antiga">🏺 Grega Antiga</option>
                                <option value="Asteca/Mexica">🐆 Asteca/Mexica</option>
                                <option value="Renascimento Italiano">🎨 Renascimento Italiano</option>
                                <option value="Japão Período Edo">🎭 Japão Período Edo</option>
                                <option value="Lakota/Dakota">🌪️ Lakota/Dakota</option>
                                <option value="Viking/Nórdico">🐺 Viking/Nórdico</option>
                                <option value="Califado Abássida">🌙 Califado Abássida</option>
                                <option value="Inglaterra Vitoriana">🎩 Inglaterra Vitoriana</option>
                                <option value="Reino de Oyó/Iorubá">🪘 Reino de Oyó/Iorubá</option>
                                <option value="Império Russo">🇷🇺 Império Russo</option>
                                <option value="Reino Ashanti/Gana">🟨 Reino Ashanti/Gana</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="subclasse">Subclasse</label>
                            <select id="subclasse" name="subclasse">
                                <option value="">Nenhuma subclasse</option>
                                <option value="Lutador">Lutador</option>
                                <option value="Armamentista">Armamentista</option>
                                <option value="Arcano">Arcano</option>
                                <option value="Naturalista">Naturalista</option>
                                <option value="Oráculo">Oráculo</option>
                                <option value="Artífice">Artífice</option>
                                <option value="Diplomata">Diplomata</option>
                                <option value="Curandeiro">Curandeiro</option>
                                <option value="Ritualista">Ritualista</option>
                                <option value="Mercador">Mercador</option>
                                <option value="Guardião">Guardião</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="anima">Ânima</label>
                            <input type="number" id="anima" name="anima" min="1" value="100" required>
                        </div>
                        <div class="form-group">
                            <label for="critico">Crítico</label>
                            <input type="number" id="critico" name="critico" min="0" step="0.1" value="1.0" required>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="aiType">Tipo de IA</label>
                        <select id="aiType" name="aiType" required>
                            <option value="aggressive">Agressiva</option>
                            <option value="passive">Passiva</option>
                            <option value="pack">Matilha</option>
                            <option value="ambush">Emboscada</option>
                            <option value="guardian">Guardião</option>
                            <option value="caster">Conjurador</option>
                            <option value="tank">Tanque</option>
                        </select>
                    </div>


                    <div class="form-group">
                        <label for="description">Descrição</label>
                        <textarea id="description" name="description" rows="3" placeholder="Descrição do personagem..."></textarea>
                    </div>

                    <div class="form-group">
                        <label>Drops</label>
                        <div class="drops-container" id="dropsContainer">
                            <button type="button" class="add-btn" onclick="addDrop()">+ Adicionar Drop</button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Skills</label>
                        <div class="skills-container" id="skillsContainer">
                            <button type="button" class="add-btn" onclick="addSkill()">+ Adicionar Skill</button>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; margin-top: 30px;">
                        <button type="submit" class="btn btn-primary" id="submitBtn">Salvar com ID Único</button>
                        <button type="button" class="btn btn-secondary" onclick="clearForm()">Limpar Formulário</button>
                    </div>

                    <div class="loading" id="loadingIndicator">
                        <p>💾 Gerando ID único e salvando...</p>
                    </div>
                </form>
            </div>

            <div class="database-section">
                <div class="database-controls">
                    <h2>Banco de Dados</h2>
                    <div style="display: flex; justify-content: center;">
                        <input type="text" class="search-box" placeholder="Buscar por nome ou ID..." id="searchBox" onkeyup="filterCharacters()">
                    </div>
                </div>

                <div class="action-buttons" style="display: flex; gap: 15px; align-items: center; justify-content: flex-end; margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <button class="btn btn-small" style="background: #6c757d; color: white;" onclick="downloadExport('js')">Download JS</button>
                    <button class="btn btn-small" style="background: #6c757d; color: white;" onclick="refreshTable()">Atualizar</button>
                    <button class="btn btn-small" style="background: #6c757d; color: white;" onclick="openBulkImportModal()">Importação</button>
                    <button class="btn btn-small" style="background: #6c757d; color: white;" onclick="bulkExportCharacters()">Exportação</button>
                    <button class="btn btn-small" style="background: #6c757d; color: white;" onclick="openBackupModal()">Backup</button>
                </div>

                <!-- Informações da Paginação -->
                <div class="pagination-info" id="paginationInfo" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px 15px; background: #f8f9fa; border-radius: 6px; font-size: 14px; color: #6c757d;">
                    <span id="itemsInfo">Carregando...</span>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span id="pageInfo"></span>
                        <button class="btn btn-small" id="viewToggleBtn" style="background: #6c757d; color: white;" onclick="toggleViewMode()">Ver Tabela</button>
                    </div>
                </div>

                <!-- Layout Cards -->
                <div class="characters-container" id="cardsContainer">
                    <div class="characters-grid" id="charactersGrid">
                        <div class="empty-state">
                            <h3>Carregando personagens...</h3>
                            <p>Por favor, aguarde enquanto os dados são carregados.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Layout Tabela -->
                <div class="table-container" id="tableContainer" style="display: none;">
                    <table class="character-table">
                        <thead>
                            <tr>
                                <th>ID (Hex)</th>
                                <th>Nome</th>
                                <th>Sprite</th>
                                <!-- Level removido -->
                                <th>HP</th>
                                <th>FÍsico</th>
                                <th>Especial</th>
                                <th>Def. Física</th>
                                <th>Def. Especial</th>
                                <th>Classe</th>
                                <th>Cultura</th>
                                <th>Subclasse</th>
                                <th>Ânima</th>
                                <th>Crítico</th>
                                <th>IA</th>
                                <th>Ações</th>
                            </tr>
                        </thead>
                        <tbody id="charactersTableBody">
                            <tr>
                                <td colspan="15" style="text-align: center; padding: 20px; color: #6c757d;">
                                    Carregando personagens...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- Controles de Paginação -->
                <div class="pagination-controls" id="paginationControls" style="display: flex; justify-content: center; align-items: center; margin-top: 20px; gap: 10px;"></div>
            </div>
        </div>
    </div>

    <!-- Modal de Edição -->
    <div class="modal-overlay" id="editModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>✏️ Editar Personagem</h2>
                <button class="close-btn" onclick="closeEditModal()">×</button>
            </div>
            <form id="editCharacterForm">
                <input type="hidden" id="editCharacterId" name="id">
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="editName">Nome do Personagem</label>
                        <input type="text" id="editName" name="name" required>
                    </div>
                    <div class="form-group">
                        <!-- Level removido do sistema -->
                    </div>
                </div>

                <div class="form-group">
                    <label for="editSprite">🖼️ Sprite (Opcional)</label>
                    <div class="upload-area" id="editSpriteContainer" onclick="triggerEditImageUpload()" style="cursor: pointer; border: 2px dashed #dee2e6; padding: 15px; border-radius: 8px; text-align: center; background: #f8f9fa;">
                        <div class="file-icon" id="editFileIcon">📥</div>
                        <div class="file-text" id="editFileText">
                            <strong>Clique para alterar sprite</strong><br>
                            ou arraste uma nova imagem aqui<br>
                        </div>
                        <div id="editSpritePreview" class="sprite-preview" style="display: none;">
                            <!-- Preview será mostrado aqui -->
                        </div>
                        <input type="file" id="editSpriteInput" name="sprite" accept=".png,.jpg,.jpeg,.gif,.webp" style="display: none;" onchange="handleEditImageUpload(event)">
                        <button type="button" id="editRemoveFileBtn" class="remove-file-btn" onclick="clearEditSpriteFile(event)" style="display: none;">Remover</button>
                    </div>
                    
                    <!-- Campo para nome do arquivo de sprite -->
                    <div class="form-group" style="margin-top: 10px;">
                        <label for="editSpriteFilename">📝 Nome do arquivo sprite</label>
                        <input type="text" id="editSpriteFilename" name="spriteFilename" placeholder="Ex: goblin_warrior.png">
                        <div style="font-size: 11px; color: #6c757d; margin-top: 2px;">
                            ✏️ <strong>Edite apenas o nome</strong> para renomear o arquivo atual<br>
                            🔄 <strong>Faça upload</strong> para substituir por nova sprite<br>
                            💡 Deixe vazio para gerar automaticamente
                        </div>
                    </div>
                    
                    <div style="font-size: 11px; color: #17a2b8; margin-top: 5px; padding: 8px; background: #e6f3ff; border-radius: 4px; border-left: 3px solid #17a2b8;">
                        <strong>💡 Dica:</strong> Você pode renomear a sprite existente alterando apenas o campo "Nome do arquivo sprite" acima, sem precisar fazer upload de nova imagem.
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="editHp">HP</label>
                        <input type="number" id="editHp" name="hp" min="1" required>
                    </div>
                    <div class="form-group">
                        <label for="editAttack">Físico</label>
                        <input type="number" id="editAttack" name="attack" min="1" required>
                    </div>
                    <div class="form-group">
                        <label for="editAtaqueEspecial">Especial</label>
                        <input type="number" id="editAtaqueEspecial" name="ataque_especial" min="1" required>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="editDefense">Defesa Física</label>
                        <input type="number" id="editDefense" name="defense" min="0" required>
                    </div>
                    <div class="form-group">
                        <label for="editDefesaEspecial">Defesa Especial</label>
                        <input type="number" id="editDefesaEspecial" name="defesa_especial" min="0" required>
                    </div>
                </div>


                <div class="form-row">
                    <div class="form-group">
                        <label for="editClasse">Classe</label>
                        <select id="editClasse" name="classe" required>
                            <option value="">Selecione uma classe...</option>
                            <!-- Classes serão carregadas dinamicamente -->
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="editCultura">Cultura</label>
                        <select id="editCultura" name="cultura">
                            <option value="">Selecione uma cultura...</option>
                            <option value="Romana">🏛️ Romana</option>
                            <option value="Chinesa">🐲 Chinesa</option>
                            <option value="Eslava">⚔️ Eslava</option>
                            <option value="Grega Antiga">🏺 Grega Antiga</option>
                            <option value="Asteca/Mexica">🐆 Asteca/Mexica</option>
                            <option value="Renascimento Italiano">🎨 Renascimento Italiano</option>
                            <option value="Japão Período Edo">🎭 Japão Período Edo</option>
                            <option value="Lakota/Dakota">🌪️ Lakota/Dakota</option>
                            <option value="Viking/Nórdico">🐺 Viking/Nórdico</option>
                            <option value="Califado Abássida">🌙 Califado Abássida</option>
                            <option value="Inglaterra Vitoriana">🎩 Inglaterra Vitoriana</option>
                            <option value="Reino de Oyó/Iorubá">🪘 Reino de Oyó/Iorubá</option>
                            <option value="Império Russo">🇷🇺 Império Russo</option>
                            <option value="Reino Ashanti/Gana">🟨 Reino Ashanti/Gana</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="editSubclasse">Subclasse</label>
                        <select id="editSubclasse" name="subclasse">
                            <option value="">Nenhuma subclasse</option>
                            <option value="Lutador">Lutador</option>
                            <option value="Armamentista">Armamentista</option>
                            <option value="Arcano">Arcano</option>
                            <option value="Naturalista">Naturalista</option>
                            <option value="Oráculo">Oráculo</option>
                            <option value="Artífice">Artífice</option>
                            <option value="Diplomata">Diplomata</option>
                            <option value="Curandeiro">Curandeiro</option>
                            <option value="Ritualista">Ritualista</option>
                            <option value="Mercador">Mercador</option>
                            <option value="Guardião">Guardião</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="editAnima">Ânima</label>
                        <input type="number" id="editAnima" name="anima" min="1" required>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="editCritico">Crítico</label>
                        <input type="number" id="editCritico" name="critico" min="0" step="0.1" required>
                    </div>
                    <div class="form-group">
                        <label for="editAiType">Tipo de IA</label>
                        <select id="editAiType" name="aiType" required>
                            <option value="aggressive">Agressiva</option>
                            <option value="passive">Passiva</option>
                            <option value="pack">Bando</option>
                            <option value="ambush">Emboscada</option>
                            <option value="guardian">Guardião</option>
                            <option value="caster">Conjurador</option>
                            <option value="tank">Tanque</option>
                        </select>
                    </div>
                </div>


                <div class="form-group">
                    <label for="editDescription">Descrição (Opcional)</label>
                    <textarea id="editDescription" name="description" rows="3" placeholder="Descrição do personagem..."></textarea>
                </div>

                <div class="form-group">
                    <label>Skills</label>
                    <div class="skills-container" id="editSkillsContainer">
                        <button type="button" class="add-btn" onclick="addEditSkill()">+ Adicionar Skill</button>
                    </div>
                </div>

                <div class="form-buttons">
                    <button type="button" class="btn btn-secondary" onclick="closeEditModal()">Cancelar</button>
                    <button type="submit" class="btn btn-primary">💾 Salvar Alterações</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal de Importação em Massa -->
    <div class="modal-overlay" id="bulkImportModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📥 Importação em Massa</h2>
                <button class="close-btn" onclick="closeBulkImportModal()">×</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <p><strong>📋 Instruções:</strong></p>
                <ul style="margin-left: 20px; color: #666;">
                    <li>Selecione um arquivo JSON com a estrutura: <code>{"characters": {...}}</code></li>
                    <li>IDs conflitantes receberão novos IDs hexadecimais automaticamente</li>
                    <li>Personagens com dados inválidos serão ignorados</li>
                    <li>Tamanho máximo do arquivo: 10MB</li>
                </ul>
            </div>

            <form id="bulkImportForm">
                <div class="form-group">
                    <label for="bulkImportFile">Arquivo JSON</label>
                    <div class="upload-area" onclick="document.getElementById('bulkImportFile').click()">
                        <div id="bulkImportPreview" class="sprite-preview">📁 Clique para selecionar arquivo JSON</div>
                        <input type="file" id="bulkImportFile" name="bulkData" accept=".json,application/json" style="display: none;" onchange="handleBulkImportFileSelect(event)">
                    </div>
                </div>

                <div id="bulkImportProgress" style="display: none; margin: 20px 0;">
                    <div style="background: #e9ecef; border-radius: 10px; overflow: hidden;">
                        <div id="bulkImportProgressBar" style="background: #28a745; height: 20px; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <p id="bulkImportProgressText" style="text-align: center; margin-top: 5px;">Processando...</p>
                </div>

                <div id="bulkImportResults" style="display: none; margin: 20px 0; max-height: 300px; overflow-y: auto;">
                    <h4>📊 Resultados da Importação:</h4>
                    <div id="bulkImportSummary"></div>
                    <div id="bulkImportDetails"></div>
                </div>

                <div class="form-buttons">
                    <button type="button" class="btn btn-secondary" onclick="closeBulkImportModal()">Cancelar</button>
                    <button type="submit" class="btn btn-primary" id="bulkImportSubmitBtn" disabled>📥 Importar Personagens</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal de Backup e Restauração -->
    <div class="modal-overlay" id="backupModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>💾 Sistema de Backup</h2>
                <button class="close-btn" onclick="closeBackupModal()">×</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <!-- Seção de Criar Backup -->
                <div style="padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h3>📦 Criar Backup</h3>
                    <p style="margin: 10px 0; font-size: 14px; color: #6c757d;">
                        Crie um backup manual dos seus personagens
                    </p>
                    <button class="btn btn-primary" onclick="createManualBackup()" id="createBackupBtn">
                        📦 Criar Backup Agora
                    </button>
                </div>
                
                <!-- Informações do Sistema -->
                <div style="padding: 20px; background: #e8f5e8; border-radius: 8px;">
                    <h3>🤖 Backups Automáticos</h3>
                    <p style="margin: 10px 0; font-size: 14px; color: #2e7d32;">
                        • Backup automático antes de deletar<br>
                        • Backup antes de importação em massa<br>
                        • Mantém últimos 10 backups automáticos
                    </p>
                </div>
            </div>
            
            <!-- Lista de Backups -->
            <div style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px;">
                <h3>📋 Backups Disponíveis</h3>
                <div id="backupList" style="margin-top: 15px;">
                    <div style="text-align: center; color: #6c757d; padding: 20px;">
                        Carregando backups...
                    </div>
                </div>
            </div>
            
            <div style="text-align: right; margin-top: 20px;">
                <button type="button" class="btn btn-secondary" onclick="closeBackupModal()">Fechar</button>
                <button type="button" class="btn btn-primary" onclick="loadBackupList()">🔄 Atualizar Lista</button>
            </div>
        </div>
    </div>

    <script>
        // Configuração da API
        const API_BASE = 'http://localhost:3002/api';
        let serverOnline = false;
        let currentImageData = null;
        
        // Variáveis para edição de sprite
        let editCurrentImageData = null;
        let originalSpriteFilename = null;


        // **FUNÇÃO ATUALIZADA**: Copiar ID para clipboard
        function copyIdToClipboard(id, element) {
            navigator.clipboard.writeText(id).then(() => {
                element.style.background = '#28a745';
                element.style.color = 'white';
                element.textContent = 'COPIADO!';
                
                setTimeout(() => {
                    element.style.background = '#e3f2fd';
                    element.style.color = '#1565c0';
                    element.textContent = id;
                }, 1000);
                
                showNotification(`📋 ID copiado: ${id}`, 'info');
            }).catch(() => {
                showNotification('❌ Erro ao copiar ID', 'error');
            });
        }

        // Verificar status do servidor
        async function checkServerStatus() {
            console.log('Verificando status do servidor...');
            console.log('API_BASE:', API_BASE);
            
            try {
                const response = await fetch(`${API_BASE}/test`);
                console.log('Response status:', response.status);
                console.log('Response ok:', response.ok);
                
                const result = await response.json();
                console.log('Result:', result);
                
                serverOnline = response.ok;
                console.log('Server online definido para:', serverOnline);
                
                updateServerStatus(true, result.idSystem || 'Hexadecimal');
                loadCharacters();
                
                // Não gerar ID exemplo automaticamente - apenas quando solicitado
            } catch (error) {
                console.error('Erro na verificação do servidor:', error);
                serverOnline = false;
                console.log('Server online definido para:', serverOnline);
                updateServerStatus(false);
                showNotification('⚠️ Servidor offline! Inicie o backend primeiro.', 'error');
            }
        }

        // **FUNÇÃO ATUALIZADA**: Atualizar indicador de status
        function updateServerStatus(online, idSystem = '') {
            const statusEl = document.getElementById('serverStatus');
            const submitBtn = document.getElementById('submitBtn');
            
            if (online) {
                statusEl.textContent = `🟢 Online (ID Preservado)`;
                statusEl.className = 'server-status online';
                submitBtn.disabled = false;
            } else {
                statusEl.textContent = '🔴 Offline';
                statusEl.className = 'server-status offline';
                submitBtn.disabled = true;
            }
        }

        // Carregar classes únicas do banco de dados
        async function loadClasses() {
            if (!serverOnline) return;
            
            try {
                const response = await fetch(`${API_BASE}/classes`);
                const data = await response.json();
                
                if (data.success) {
                    // Atualizar selects de classe
                    updateClassSelects(data.classes);
                } else {
                    throw new Error(data.error || 'Erro ao carregar classes');
                }
                
            } catch (error) {
                console.error('Erro ao carregar classes:', error);
                // Fallback para classes padrão se houver erro
                updateClassSelects(['Lutador', 'Armamentista', 'Arcano']);
            }
        }
        
        // Atualizar os selects de classe
        function updateClassSelects(classes) {
            const createSelect = document.getElementById('classe');
            const editSelect = document.getElementById('editClasse');
            
            // Limpar e adicionar opção padrão
            createSelect.innerHTML = '<option value="">Selecione uma classe...</option>';
            editSelect.innerHTML = '<option value="">Selecione uma classe...</option>';
            
            // Adicionar classes do banco
            classes.forEach(classe => {
                const optionCreate = document.createElement('option');
                optionCreate.value = classe;
                optionCreate.textContent = classe;
                createSelect.appendChild(optionCreate);
                
                const optionEdit = document.createElement('option');
                optionEdit.value = classe;
                optionEdit.textContent = classe;
                editSelect.appendChild(optionEdit);
            });
            
            // Adicionar opção para nova classe
            const newClassOption1 = document.createElement('option');
            newClassOption1.value = 'NOVA_CLASSE';
            newClassOption1.textContent = '+ Criar nova classe';
            createSelect.appendChild(newClassOption1);
            
            const newClassOption2 = document.createElement('option');
            newClassOption2.value = 'NOVA_CLASSE';
            newClassOption2.textContent = '+ Criar nova classe';
            editSelect.appendChild(newClassOption2);
        }
        
        // Salvar nova classe diretamente no banco de dados
        async function saveClassToDatabase(className) {
            if (!serverOnline) {
                showNotification('Servidor offline! Não é possível salvar a classe.', 'error');
                return false;
            }
            
            try {
                const response = await fetch(`${API_BASE}/classes`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        className: className
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showNotification(`✅ Classe '${className}' criada com sucesso!`, 'success');
                    return true;
                } else {
                    showNotification(`❌ Erro ao criar classe: ${result.error}`, 'error');
                    return false;
                }
            } catch (error) {
                console.error('Erro ao salvar classe:', error);
                showNotification('Erro de conexão ao salvar classe', 'error');
                return false;
            }
        }
        
        // Lidar com seleção de nova classe
        async function handleClassSelection(selectElement) {
            if (selectElement.value === 'NOVA_CLASSE') {
                const newClassName = prompt('Digite o nome da nova classe:');
                if (newClassName && newClassName.trim()) {
                    const cleanClassName = newClassName.trim();
                    
                    // Salvar classe diretamente no banco
                    const success = await saveClassToDatabase(cleanClassName);
                    
                    if (success) {
                        // Recarregar classes para sincronizar
                        await loadClasses();
                        // Selecionar a nova classe
                        selectElement.value = cleanClassName;
                    } else {
                        selectElement.value = '';
                    }
                } else {
                    selectElement.value = '';
                }
            }
        }

        // Carregar personagens do servidor
        // **FUNÇÃO ATUALIZADA**: Carregar personagens do servidor com paginação
        async function loadCharacters(retries = 3) {
            if (!serverOnline) return;
            
            try {
                const response = await fetch(`${API_BASE}/characters`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                allCharacters = data.characters || data || {};
                filteredCharacters = allCharacters;
                currentPage = 1;
                renderTable(filteredCharacters, currentPage);
            } catch (error) {
                console.error('Erro ao carregar personagens:', error);
                
                // Tentar novamente se ainda temos tentativas
                if (retries > 0) {
                    console.log(`Tentando novamente... (${retries} tentativas restantes)`);
                    setTimeout(() => loadCharacters(retries - 1), 500);
                } else {
                    showNotification('Erro ao carregar dados do servidor', 'error');
                }
            }
        }

        // Trigger upload de imagem
        function triggerImageUpload() {
            if (serverOnline) {
                document.getElementById('spriteInput').click();
            } else {
                showNotification('Servidor offline! Não é possível fazer upload.', 'error');
            }
        }

        // Manipular upload de imagem
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Verificar tipo de arquivo
            const validTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/gif', 'image/webp'];
            if (!validTypes.includes(file.type)) {
                showNotification('Formato de arquivo não suportado!', 'error');
                return;
            }

            // Verificar tamanho (máx 2MB)
            if (file.size > 2 * 1024 * 1024) {
                showNotification('Arquivo muito grande! Máximo 2MB.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                currentImageData = e.target.result;
                updateImagePreview(file);
                
                // Upload automático da sprite
                if (serverOnline) {
                    uploadSprite(e.target.result, file.name);
                }
            };
            reader.readAsDataURL(file);
        }

        // Upload da sprite para o servidor
        async function uploadSprite(imageData, originalName) {
            const nameInput = document.getElementById('name').value.trim();
            const filenameInput = document.getElementById('spriteFilename');
            
            if (!nameInput) {
                showNotification('Digite o nome do personagem primeiro!', 'error');
                return;
            }

            const extension = originalName.split('.').pop().toLowerCase();
            const suggestedName = `${nameInput.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '')}.${extension}`;
            
            // Sempre usar o nome sugerido baseado no nome do personagem
            filenameInput.value = suggestedName;

            try {
                const response = await fetch(`${API_BASE}/upload-sprite`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        imageData: imageData,
                        filename: filenameInput.value || suggestedName
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    showNotification(`✅ Sprite salva automaticamente em: ${result.path}`, 'success');
                    document.getElementById('spriteContainer').classList.add('uploaded');
                    updateSpritePreview();
                } else {
                    showNotification('Erro ao salvar sprite: ' + result.error, 'error');
                }
            } catch (error) {
                showNotification('Erro de conexão ao salvar sprite', 'error');
            }
        }

        // Atualizar preview da imagem
        function updateImagePreview(file) {
            const preview = document.getElementById('imagePreview');
            const fileInfo = document.getElementById('fileInfo');
            const removeBtn = document.getElementById('removeFileBtn');
            const uploadText = document.getElementById('fileText');
            const uploadIcon = document.getElementById('fileIcon');
            const container = document.getElementById('spriteContainer');

            preview.src = currentImageData;
            preview.style.display = 'block';
            removeBtn.style.display = 'inline-block';
            
            uploadText.style.display = 'none';
            uploadIcon.style.display = 'none';
            container.classList.add('has-upload');

            const sizeKB = Math.round(file.size / 1024);
            fileInfo.textContent = `Upload: ${file.name} (${sizeKB}KB)`;

            updateSpritePreview();
        }

        // Atualizar preview do caminho
        function updateSpritePreview() {
            const nameInput = document.getElementById('name');
            const filenameInput = document.getElementById('spriteFilename');
            const preview = document.getElementById('spritePreview');
            
            const filename = filenameInput.value.trim();
            
            if (filename) {
                const spritePath = `assets/sprites/${filename}`;
                preview.innerHTML = `📁 Salvo em: <strong>${spritePath}</strong>`;
                preview.classList.add('show');
            } else {
                preview.classList.remove('show');
            }
        }

        // Limpar arquivo sprite
        function clearSpriteFile(event) {
            event.stopPropagation();
            
            currentImageData = null;
            const preview = document.getElementById('imagePreview');
            const fileInfo = document.getElementById('fileInfo');
            const removeBtn = document.getElementById('removeFileBtn');
            const uploadText = document.getElementById('fileText');
            const uploadIcon = document.getElementById('fileIcon');
            const input = document.getElementById('spriteInput');
            const container = document.getElementById('spriteContainer');
            const filenameInput = document.getElementById('spriteFilename');
            const spritePreview = document.getElementById('spritePreview');

            preview.style.display = 'none';
            removeBtn.style.display = 'none';
            uploadText.style.display = 'block';
            uploadIcon.style.display = 'block';
            fileInfo.textContent = '';
            input.value = '';
            filenameInput.value = '';
            
            container.classList.remove('has-upload', 'uploaded');
            spritePreview.classList.remove('show');
        }

        // Event listeners
        document.getElementById('name').addEventListener('input', updateSpritePreview);
        document.getElementById('spriteFilename').addEventListener('input', updateSpritePreview);

        // Drag and Drop
        const uploadContainer = document.getElementById('spriteContainer');
        
        uploadContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
            if (serverOnline) {
                uploadContainer.classList.add('dragover');
            }
        });

        uploadContainer.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadContainer.classList.remove('dragover');
        });

        uploadContainer.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadContainer.classList.remove('dragover');
            
            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const input = document.getElementById('spriteInput');
                
                const dt = new DataTransfer();
                dt.items.add(file);
                input.files = dt.files;
                
                handleImageUpload({ target: { files: [file] } });
            }
        });

        // Adicionar drop
        function addDrop() {
            const container = document.getElementById('dropsContainer');
            const dropDiv = document.createElement('div');
            dropDiv.className = 'drop-item';
            dropDiv.innerHTML = `
                <input type="text" placeholder="Nome do item" name="dropName[]">
                <input type="number" placeholder="Chance (0-1)" step="0.01" min="0" max="1" name="dropChance[]">
                <input type="text" placeholder="Tipo" name="dropType[]">
                <input type="number" placeholder="Valor" name="dropValue[]">
                <button type="button" class="remove-btn" onclick="this.parentElement.remove()">×</button>
            `;
            container.appendChild(dropDiv);
        }

        // Adicionar skill - Integração com módulo de skills
        async function addSkill() {
            try {
                // Buscar skills disponíveis do módulo de skills
                const response = await fetch('/api/skills');
                const data = await response.json();
                
                if (!data.success || !data.data.skills) {
                    showNotification('Erro ao carregar skills disponíveis', 'error');
                    return;
                }
                
                const skills = data.data.skills;
                
                if (skills.length === 0) {
                    showNotification('Nenhuma skill encontrada. Crie skills primeiro no módulo Skills.', 'info');
                    return;
                }

                const container = document.getElementById('skillsContainer');
                const skillDiv = document.createElement('div');
                skillDiv.className = 'skill-item';
                
                // Criar select com skills disponíveis
                let skillOptions = '<option value="">Selecione uma skill...</option>';
                skills.forEach(skill => {
                    const sprite = skill.sprite ? `🎨` : '';
                    skillOptions += `<option value="${skill.id}" data-name="${skill.name}" data-damage="${skill.damage}" data-mana="${skill.mana_cost}" data-type="${skill.type}">${sprite} ${skill.name} (${skill.type} - Dano: ${skill.damage})</option>`;
                });

                skillDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                        <select name="skillId[]" onchange="updateSkillInfo(this)" style="flex: 1; min-width: 200px;">
                            ${skillOptions}
                        </select>
                        <input type="text" placeholder="Nome da skill" name="skillName[]" readonly style="width: 150px;" title="Nome da skill selecionada">
                        <input type="number" placeholder="Dano" name="skillDamage[]" readonly style="width: 80px;" title="Dano base da skill">
                        <input type="number" placeholder="Custo mana" name="skillMana[]" readonly style="width: 80px;" title="Custo de mana">
                        <span class="skill-type" name="skillType[]" style="background: #e9ecef; padding: 4px 8px; border-radius: 4px; font-size: 0.8em;"></span>
                        <button type="button" class="remove-btn" onclick="this.parentElement.parentElement.remove()" title="Remover skill">×</button>
                    </div>
                `;
                container.appendChild(skillDiv);
                
                showNotification(`${skills.length} skills carregadas do módulo Skills`, 'success');
                
            } catch (error) {
                console.error('Erro ao buscar skills:', error);
                showNotification('Erro ao conectar com o módulo de Skills', 'error');
            }
        }

        // Função para atualizar informações da skill selecionada
        function updateSkillInfo(selectElement) {
            const skillDiv = selectElement.parentElement;
            const selectedOption = selectElement.options[selectElement.selectedIndex];
            
            if (selectedOption.value) {
                // Preencher campos com dados da skill selecionada
                skillDiv.querySelector('input[name="skillName[]"]').value = selectedOption.getAttribute('data-name');
                skillDiv.querySelector('input[name="skillDamage[]"]').value = selectedOption.getAttribute('data-damage');
                skillDiv.querySelector('input[name="skillMana[]"]').value = selectedOption.getAttribute('data-mana');
                skillDiv.querySelector('.skill-type').textContent = selectedOption.getAttribute('data-type');
                skillDiv.querySelector('.skill-type').style.background = getTypeColor(selectedOption.getAttribute('data-type'));
            } else {
                // Limpar campos se nenhuma skill estiver selecionada
                skillDiv.querySelector('input[name="skillName[]"]').value = '';
                skillDiv.querySelector('input[name="skillDamage[]"]').value = '';
                skillDiv.querySelector('input[name="skillMana[]"]').value = '';
                skillDiv.querySelector('.skill-type').textContent = '';
                skillDiv.querySelector('.skill-type').style.background = '#e9ecef';
            }
        }

        // Função para obter cor baseada no tipo da skill
        function getTypeColor(type) {
            const colors = {
                'combat': '#dc3545',
                'magic': '#6f42c1',
                'healing': '#28a745',
                'passive': '#6c757d',
                'utility': '#17a2b8',
                'buff': '#ffc107',
                'debuff': '#fd7e14'
            };
            return colors[type] || '#e9ecef';
        }

        // Adicionar skill no modal de edição - Integração com módulo de skills
        async function addEditSkill() {
            try {
                // Buscar skills disponíveis do módulo de skills
                const response = await fetch('/api/skills');
                const data = await response.json();
                
                if (!data.success || !data.data.skills) {
                    showNotification('Erro ao carregar skills disponíveis', 'error');
                    return;
                }
                
                const skills = data.data.skills;
                
                if (skills.length === 0) {
                    showNotification('Nenhuma skill encontrada. Crie skills primeiro no módulo Skills.', 'info');
                    return;
                }

                const container = document.getElementById('editSkillsContainer');
                const skillDiv = document.createElement('div');
                skillDiv.className = 'skill-item';
                
                // Criar select com skills disponíveis
                let skillOptions = '<option value="">Selecione uma skill...</option>';
                skills.forEach(skill => {
                    const sprite = skill.sprite ? `🎨` : '';
                    skillOptions += `<option value="${skill.id}" data-name="${skill.name}" data-damage="${skill.damage}" data-mana="${skill.mana_cost}" data-type="${skill.type}">${sprite} ${skill.name} (${skill.type} - Dano: ${skill.damage})</option>`;
                });

                skillDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                        <select name="editSkillId[]" onchange="updateEditSkillInfo(this)" style="flex: 1; min-width: 200px;">
                            ${skillOptions}
                        </select>
                        <input type="text" placeholder="Nome da skill" name="editSkillName[]" readonly style="width: 150px;" title="Nome da skill selecionada">
                        <input type="number" placeholder="Dano" name="editSkillDamage[]" readonly style="width: 80px;" title="Dano base da skill">
                        <input type="number" placeholder="Custo mana" name="editSkillMana[]" readonly style="width: 80px;" title="Custo de mana">
                        <span class="skill-type" name="editSkillType[]" style="background: #e9ecef; padding: 4px 8px; border-radius: 4px; font-size: 0.8em;"></span>
                        <button type="button" class="remove-btn" onclick="this.parentElement.parentElement.remove()" title="Remover skill">×</button>
                    </div>
                `;
                container.appendChild(skillDiv);
                
                showNotification(`${skills.length} skills carregadas para edição`, 'success');
                
            } catch (error) {
                console.error('Erro ao buscar skills para edição:', error);
                showNotification('Erro ao conectar com o módulo de Skills', 'error');
            }
        }

        // Função para atualizar informações da skill selecionada no modal de edição
        function updateEditSkillInfo(selectElement) {
            const skillDiv = selectElement.parentElement;
            const selectedOption = selectElement.options[selectElement.selectedIndex];
            
            if (selectedOption.value) {
                // Preencher campos com dados da skill selecionada
                skillDiv.querySelector('input[name="editSkillName[]"]').value = selectedOption.getAttribute('data-name');
                skillDiv.querySelector('input[name="editSkillDamage[]"]').value = selectedOption.getAttribute('data-damage');
                skillDiv.querySelector('input[name="editSkillMana[]"]').value = selectedOption.getAttribute('data-mana');
                skillDiv.querySelector('.skill-type').textContent = selectedOption.getAttribute('data-type');
                skillDiv.querySelector('.skill-type').style.background = getTypeColor(selectedOption.getAttribute('data-type'));
            } else {
                // Limpar campos se nenhuma skill estiver selecionada
                skillDiv.querySelector('input[name="editSkillName[]"]').value = '';
                skillDiv.querySelector('input[name="editSkillDamage[]"]').value = '';
                skillDiv.querySelector('input[name="editSkillMana[]"]').value = '';
                skillDiv.querySelector('.skill-type').textContent = '';
                skillDiv.querySelector('.skill-type').style.background = '#e9ecef';
            }
        }

        // Função para carregar skills existentes do personagem no modal de edição
        async function loadExistingSkills(characterSkills) {
            try {
                // Buscar todas as skills disponíveis
                const response = await fetch('/api/skills');
                const data = await response.json();
                
                if (!data.success || !data.data.skills) {
                    console.log('Não foi possível carregar skills disponíveis');
                    return;
                }
                
                const availableSkills = data.data.skills;
                const container = document.getElementById('editSkillsContainer');
                
                // Limpar container (manter apenas o botão)
                container.innerHTML = '<button type="button" class="add-btn" onclick="addEditSkill()">+ Adicionar Skill</button>';
                
                // Adicionar skills existentes
                for (const characterSkill of characterSkills) {
                    // Encontrar a skill correspondente no módulo skills
                    const skillData = availableSkills.find(skill => skill.id === characterSkill.skillId || skill.name === characterSkill.skillName);
                    
                    if (skillData) {
                        await addExistingSkillToEdit(skillData);
                    } else {
                        // Skill não encontrada no módulo skills (possivelmente skill manual antiga)
                        addLegacySkillToEdit(characterSkill);
                    }
                }
                
            } catch (error) {
                console.error('Erro ao carregar skills existentes:', error);
            }
        }

        // Adicionar skill existente ao modal de edição
        async function addExistingSkillToEdit(skillData) {
            try {
                const response = await fetch('/api/skills');
                const data = await response.json();
                const allSkills = data.data.skills;
                
                const container = document.getElementById('editSkillsContainer');
                const skillDiv = document.createElement('div');
                skillDiv.className = 'skill-item';
                
                // Criar select com skills disponíveis
                let skillOptions = '<option value="">Selecione uma skill...</option>';
                allSkills.forEach(skill => {
                    const sprite = skill.sprite ? `🎨` : '';
                    const selected = skill.id === skillData.id ? 'selected' : '';
                    skillOptions += `<option value="${skill.id}" data-name="${skill.name}" data-damage="${skill.damage}" data-mana="${skill.mana_cost}" data-type="${skill.type}" ${selected}>${sprite} ${skill.name} (${skill.type} - Dano: ${skill.damage})</option>`;
                });

                skillDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                        <select name="editSkillId[]" onchange="updateEditSkillInfo(this)" style="flex: 1; min-width: 200px;">
                            ${skillOptions}
                        </select>
                        <input type="text" placeholder="Nome da skill" name="editSkillName[]" readonly style="width: 150px;" value="${skillData.name}" title="Nome da skill selecionada">
                        <input type="number" placeholder="Dano" name="editSkillDamage[]" readonly style="width: 80px;" value="${skillData.damage}" title="Dano base da skill">
                        <input type="number" placeholder="Custo mana" name="editSkillMana[]" readonly style="width: 80px;" value="${skillData.mana_cost}" title="Custo de mana">
                        <span class="skill-type" name="editSkillType[]" style="background: ${getTypeColor(skillData.type)}; padding: 4px 8px; border-radius: 4px; font-size: 0.8em; color: white;">${skillData.type}</span>
                        <button type="button" class="remove-btn" onclick="this.parentElement.parentElement.remove()" title="Remover skill">×</button>
                    </div>
                `;
                container.appendChild(skillDiv);
                
            } catch (error) {
                console.error('Erro ao adicionar skill existente:', error);
            }
        }

        // Adicionar skill legada (manual) ao modal de edição
        function addLegacySkillToEdit(skillData) {
            const container = document.getElementById('editSkillsContainer');
            const skillDiv = document.createElement('div');
            skillDiv.className = 'skill-item';
            
            skillDiv.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; background: #fff3cd; padding: 8px; border-radius: 4px; border: 1px solid #ffeaa7;">
                    <span style="color: #856404; font-size: 0.9em; flex: 1;">
                        ⚠️ Skill Legada: ${skillData.skillName || 'Nome não informado'} 
                        (Dano: ${skillData.skillDamage || 0}, Custo: ${skillData.skillCost || 0})
                    </span>
                    <button type="button" class="remove-btn" onclick="this.parentElement.parentElement.remove()" title="Remover skill legada">×</button>
                    <input type="hidden" name="legacySkillName[]" value="${skillData.skillName || ''}">
                    <input type="hidden" name="legacySkillDamage[]" value="${skillData.skillDamage || 0}">
                    <input type="hidden" name="legacySkillCost[]" value="${skillData.skillCost || 0}">
                </div>
            `;
            container.appendChild(skillDiv);
        }

        // Processar skills editadas para envio ao servidor
        function processEditedSkills() {
            const skillsArray = [];
            const container = document.getElementById('editSkillsContainer');
            
            // Coletar skills do módulo Skills (novas)
            const skillIdElements = container.querySelectorAll('select[name="editSkillId[]"]');
            skillIdElements.forEach(selectElement => {
                const skillId = selectElement.value;
                if (skillId) {
                    const skillDiv = selectElement.parentElement;
                    const skillName = skillDiv.querySelector('input[name="editSkillName[]"]').value;
                    const skillDamage = skillDiv.querySelector('input[name="editSkillDamage[]"]').value;
                    const skillMana = skillDiv.querySelector('input[name="editSkillMana[]"]').value;
                    const skillType = skillDiv.querySelector('.skill-type').textContent;
                    
                    skillsArray.push({
                        skillId: skillId,
                        skillName: skillName,
                        skillDamage: parseInt(skillDamage) || 0,
                        skillMana: parseInt(skillMana) || 0,
                        skillType: skillType,
                        source: 'skills_module'
                    });
                }
            });
            
            // Coletar skills legadas (skills manuais antigas)
            const legacySkillNames = container.querySelectorAll('input[name="legacySkillName[]"]');
            legacySkillNames.forEach((nameInput, index) => {
                const skillName = nameInput.value;
                if (skillName) {
                    const damageInputs = container.querySelectorAll('input[name="legacySkillDamage[]"]');
                    const costInputs = container.querySelectorAll('input[name="legacySkillCost[]"]');
                    
                    skillsArray.push({
                        skillName: skillName,
                        skillDamage: parseInt(damageInputs[index]?.value) || 0,
                        skillCost: parseInt(costInputs[index]?.value) || 0,
                        source: 'legacy'
                    });
                }
            });
            
            console.log('Skills processadas para edição:', skillsArray);
            return skillsArray;
        }

        // **FUNÇÃO ATUALIZADA**: Processar formulário com IDs hexadecimais
        document.getElementById('characterForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            if (!serverOnline) {
                showNotification('Servidor offline! Não é possível salvar.', 'error');
                return;
            }

            const loadingIndicator = document.getElementById('loadingIndicator');
            const submitBtn = document.getElementById('submitBtn');
            
            loadingIndicator.classList.add('show');
            submitBtn.disabled = true;
            
            try {
                console.log('Iniciando criação de personagem...');
                console.log('Server online:', serverOnline);
                
                const formData = new FormData();
                
                // Dados básicos - com logging para debug
                const name = document.getElementById('name').value;
                const level = document.getElementById('level').value;
                const classe = document.getElementById('classe').value;
                
                console.log('Dados básicos:', { name, level, classe });
                
                formData.append('name', name);
                formData.append('level', level);
                formData.append('hp', document.getElementById('hp').value);
                formData.append('attack', document.getElementById('attack').value);
                formData.append('defense', document.getElementById('defense').value);
                formData.append('defesa_especial', document.getElementById('defesa_especial').value);
                formData.append('classe', classe);
                formData.append('anima', document.getElementById('anima').value);
                formData.append('critico', document.getElementById('critico').value);
                formData.append('aiType', document.getElementById('aiType').value);
                formData.append('description', document.getElementById('description').value);
                formData.append('spriteFilename', document.getElementById('spriteFilename').value);

                // Sprite file (se houver)
                const spriteInput = document.getElementById('spriteInput');
                if (spriteInput.files[0]) {
                    formData.append('sprite', spriteInput.files[0]);
                }

                // Coletar drops
                const drops = [];
                const dropNames = document.getElementsByName('dropName[]');
                const dropChances = document.getElementsByName('dropChance[]');
                const dropTypes = document.getElementsByName('dropType[]');
                const dropValues = document.getElementsByName('dropValue[]');
                
                console.log('Drops encontradas:', dropNames.length);
                console.log('Drop chances encontradas:', dropChances.length);
                console.log('Drop types encontradas:', dropTypes.length);
                console.log('Drop values encontradas:', dropValues.length);
                
                for (let i = 0; i < dropNames.length; i++) {
                    if (dropNames[i] && dropNames[i].value && dropNames[i].value.trim()) {
                        const dropName = dropNames[i].value;
                        const dropChance = dropChances[i] ? parseFloat(dropChances[i].value) || 0.1 : 0.1;
                        const dropType = dropTypes[i] ? dropTypes[i].value || 'material' : 'material';
                        const dropValue = dropValues[i] ? parseInt(dropValues[i].value) || 5 : 5;
                        
                        console.log(`Drop ${i}:`, { dropName, dropChance, dropType, dropValue });
                        
                        drops.push({
                            item: dropName,
                            chance: dropChance,
                            type: dropType,
                            value: dropValue
                        });
                    }
                }
                formData.append('drops', JSON.stringify(drops));

                // Coletar skills
                const skills = [];
                const skillNames = document.getElementsByName('skillName[]');
                const skillDamages = document.getElementsByName('skillDamage[]');
                const skillCosts = document.getElementsByName('skillCost[]');
                const skillChances = document.getElementsByName('skillChance[]');
                
                console.log('Skills encontradas:', skillNames.length);
                console.log('Damages encontradas:', skillDamages.length);
                console.log('Costs encontradas:', skillCosts.length);
                console.log('Chances encontradas:', skillChances.length);
                
                for (let i = 0; i < skillNames.length; i++) {
                    if (skillNames[i] && skillNames[i].value && skillNames[i].value.trim()) {
                        const skillName = skillNames[i].value;
                        const skillDamage = skillDamages[i] ? parseInt(skillDamages[i].value) || 10 : 10;
                        const skillCost = skillCosts[i] ? parseInt(skillCosts[i].value) || 5 : 5;
                        const skillChance = skillChances[i] ? parseFloat(skillChances[i].value) || 0.3 : 0.3;
                        
                        console.log(`Skill ${i}:`, { skillName, skillDamage, skillCost, skillChance });
                        
                        skills.push({
                            name: skillName,
                            damage: skillDamage,
                            stamina_cost: skillCost,
                            chance: skillChance
                        });
                    }
                }
                formData.append('skills', JSON.stringify(skills));

                // Enviar para o servidor
                console.log('Enviando requisição para:', `${API_BASE}/characters`);
                console.log('FormData preparado');
                
                const response = await fetch(`${API_BASE}/characters`, {
                    method: 'POST',
                    body: formData
                });
                
                console.log('Response status:', response.status);
                console.log('Response OK:', response.ok);

                const result = await response.json();
                console.log('Result:', result);
                
                if (result.success) {
                    showNotification(`✅ Personagem salvo com ID IMUTÁVEL: ${result.character.id}!
🔒 Este ID nunca será alterado
📁 Sprite: ${result.files.sprite || 'Nenhuma'}
📄 Banco: ${result.files.database}  
🚀 Export: ${result.files.export}`, 'success');
                    
                    clearForm();
                    // Aguardar um momento para garantir que o servidor terminou de salvar
                    setTimeout(() => loadCharacters(), 300);
                } else {
                    showNotification('Erro ao salvar: ' + result.error, 'error');
                }

            } catch (error) {
                console.error('Erro completo:', error);
                console.error('Stack trace:', error.stack);
                console.error('Mensagem:', error.message);
                
                let errorMessage = 'Erro de conexão com o servidor';
                if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'Falha na conexão com o servidor. Verifique se o backend está rodando.';
                } else if (error.message.includes('NetworkError')) {
                    errorMessage = 'Erro de rede. Verifique sua conexão.';
                }
                
                showNotification(`${errorMessage} - Detalhes: ${error.message}`, 'error');
            } finally {
                loadingIndicator.classList.remove('show');
                submitBtn.disabled = false;
            }
        });

        // Limpar formulário
        function clearForm() {
            document.getElementById('characterForm').reset();
            document.getElementById('dropsContainer').innerHTML = '<button type="button" class="add-btn" onclick="addDrop()">+ Adicionar Drop</button>';
            document.getElementById('skillsContainer').innerHTML = '<button type="button" class="add-btn" onclick="addSkill()">+ Adicionar Skill</button>';
            clearSpriteFile(new Event('click'));
        }

        // **VARIÁVEIS DE PAGINAÇÃO E LAYOUT**
        let currentPage = 1;
        let itemsPerPage = 20;
        let allCharacters = {};
        let filteredCharacters = {};
        let viewMode = 'cards'; // 'cards' ou 'table'

        // **FUNÇÃO ATUALIZADA**: Renderizar tabela com paginação
        // **FUNÇÃO UNIFICADA**: Renderizar cards ou tabela baseado no viewMode
        function renderTable(characters, page = 1) {
            if (viewMode === 'cards') {
                renderCards(characters, page);
            } else {
                renderTableView(characters, page);
            }
        }
        
        // Renderizar layout de cards
        function renderCards(characters, page = 1) {
            const container = document.getElementById('charactersGrid');
            container.innerHTML = '';

            if (!characters || Object.keys(characters).length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <h3>Nenhum personagem encontrado</h3>
                        <p>Nenhum personagem foi cadastrado ainda ou corresponde à sua pesquisa.</p>
                    </div>
                `;
                updatePaginationInfo(0, 0);
                renderPaginationControls(0);
                return;
            }

            // Calcular paginação
            const charactersArray = Object.values(characters);
            const totalItems = charactersArray.length;
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            const startIndex = (page - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageCharacters = charactersArray.slice(startIndex, endIndex);

            // Atualizar informações da paginação
            updatePaginationInfo(totalItems, totalPages);
            renderPaginationControls(totalPages);

            // Renderizar personagens como cards
            pageCharacters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card';
                
                // Level system removido

                // Criar seção da sprite
                let spriteSection = `<div class="sprite-placeholder">🎭</div>`;
                if (char.sprite) {
                    const timestamp = new Date().getTime();
                    const spriteUrl = `http://localhost:3002/${char.sprite}?v=${timestamp}`;
                    spriteSection = `
                        <img src="${spriteUrl}" 
                             alt="${char.name}" 
                             title="Sprite: ${char.name}"
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div class="sprite-error" style="display: none;">❌</div>
                    `;
                }

                // ID com estilo
                const isHexId = /^[A-F0-9]{10}$/i.test(char.id);
                const idType = isHexId ? 'HEX' : 'LEGACY';
                const idColor = isHexId ? '#1565c0' : '#f57c00';
                const idBg = isHexId ? '#e3f2fd' : '#fff3e0';

                card.innerHTML = `
                    <div class="character-header">
                        <h3 class="character-name">${char.name}</h3>
                        <span class="character-id-card" 
                              onclick="copyIdToClipboard('${char.id}', this)"
                              title="Clique para copiar: ${char.id} (${idType})"
                              style="background: ${idBg}; color: ${idColor};">
                            ${char.id}
                        </span>
                    </div>
                    
                    <div class="character-sprite-section">
                        <div class="character-sprite-card">
                            ${spriteSection}
                        </div>
                        <div>
                            <div class="stat-item" style="display: inline-block; margin-right: 10px;">
                                <div class="stat-label">Level</div>
                                <!-- Level removido -->
                            </div>
                            <div class="stat-item" style="display: inline-block;">
                                <div class="stat-label">IA</div>
                                <div class="stat-value ai-type ai-${char.ai_type}">${char.ai_type || 'N/A'}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="character-stats">
                        <div class="stat-item">
                            <div class="stat-label">HP</div>
                            <div class="stat-value">${char.hp}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Físico</div>
                            <div class="stat-value">${char.attack}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Especial</div>
                            <div class="stat-value">${char.ataque_especial || char.attack || 'N/A'}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Def. Física</div>
                            <div class="stat-value">${char.defense}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Def. Especial</div>
                            <div class="stat-value">${char.defesa_especial || 'N/A'}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Classe</div>
                            <div class="stat-value class-badge">${char.classe || 'Lutador'}</div>
                        </div>
                        ${char.cultura ? `<div class="stat-item">
                            <div class="stat-label">Cultura</div>
                            <div class="stat-value culture-badge">${char.cultura}</div>
                        </div>` : ''}
                        ${char.subclasse ? `<div class="stat-item">
                            <div class="stat-label">Subclasse</div>
                            <div class="stat-value subclass-badge">${char.subclasse}</div>
                        </div>` : ''}
                        <div class="stat-item">
                            <div class="stat-label">Ânima</div>
                            <div class="stat-value">${char.anima || 100}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Crítico</div>
                            <div class="stat-value">${char.critico || 1.0}</div>
                        </div>
                    </div>
                    
                    <div class="character-actions">
                        <button class="btn btn-primary btn-small" onclick="editCharacter('${char.id}')">
                            ✏️ Editar
                        </button>
                        <button class="btn btn-danger btn-small" onclick="deleteCharacter('${char.id}')">
                            🗑️ Excluir
                        </button>
                    </div>
                `;
                
                container.appendChild(card);
            });
        }
        
        // Renderizar layout de tabela
        function renderTableView(characters, page = 1) {
            const tbody = document.getElementById('charactersTableBody');
            tbody.innerHTML = '';

            if (!characters || Object.keys(characters).length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="15" style="text-align: center; padding: 20px; color: #6c757d;">
                            Nenhum personagem cadastrado ainda.
                        </td>
                    </tr>
                `;
                updatePaginationInfo(0, 0);
                renderPaginationControls(0);
                return;
            }

            // Calcular paginação
            const charactersArray = Object.values(characters);
            const totalItems = charactersArray.length;
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            const startIndex = (page - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageCharacters = charactersArray.slice(startIndex, endIndex);

            // Atualizar informações da paginação
            updatePaginationInfo(totalItems, totalPages);
            renderPaginationControls(totalPages);

            // Renderizar personagens da página atual
            pageCharacters.forEach(char => {
                const row = document.createElement('tr');
                
                // Level system removido

                // Criar célula da sprite com imagem real + cache busting
                let spriteCell = `<div class="sprite-placeholder">🎭</div>`;
                if (char.sprite) {
                    const timestamp = new Date().getTime();
                    const spriteUrl = `http://localhost:3002/${char.sprite}?v=${timestamp}`;
                    spriteCell = `
                        <img src="${spriteUrl}" 
                             alt="${char.name}" 
                             title="Sprite: ${char.name}"
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div class="sprite-error" style="display: none;">❌ Erro ao carregar</div>
                        <div class="sprite-path-text">${char.sprite.split('/').pop()}</div>
                    `;
                }

                // **NOVO**: Célula do ID com indicação de tipo apenas no tooltip
                let hexIdCell;
                const isHexId = /^[A-F0-9]{10}$/i.test(char.id);
                const idType = isHexId ? 'HEX' : 'LEGACY';
                const idColor = isHexId ? '#1565c0' : '#f57c00';
                const idBg = isHexId ? '#e3f2fd' : '#fff3e0';
                
                hexIdCell = `
                    <span class="character-id tooltip" 
                          onclick="copyIdToClipboard('${char.id}', this)"
                          title="Clique para copiar: ${char.id} (${idType})"
                          style="background: ${idBg}; color: ${idColor}; border-color: ${idColor}40;">
                        ${char.id}
                    </span>
                `;

                // Truncar nome para a tabela
                const truncatedName = truncateText(char.name, 10);
                
                row.innerHTML = `
                    <td>${hexIdCell}</td>
                    <td><strong title="${char.name}">${truncatedName}</strong></td>
                    <td class="character-sprite">${spriteCell}</td>
                    <!-- Level removido -->
                    <td>${char.hp}</td>
                    <td>${char.attack}</td>
                    <td>${char.ataque_especial || char.attack || 'N/A'}</td>
                    <td>${char.defense}</td>
                    <td>${char.defesa_especial || 'N/A'}</td>
                    <td><span class="class-badge">${char.classe || 'Lutador'}</span></td>
                    <td>${char.cultura ? `<span class="culture-badge">${char.cultura}</span>` : 'N/A'}</td>
                    <td>${char.subclasse ? `<span class="subclass-badge">${char.subclasse}</span>` : 'N/A'}</td>
                    <td>${char.anima || 100}</td>
                    <td>${char.critico || 1.0}</td>
                    <td><span class="ai-type ai-${char.ai_type}">${char.ai_type || 'N/A'}</span></td>
                    <td>
                        <button class="btn btn-primary btn-small" onclick="editCharacter('${char.id}')" style="margin-right: 5px;">✏️ Editar</button>
                        <button class="btn btn-danger btn-small" onclick="deleteCharacter('${char.id}')">🗑️ Excluir</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        // **FUNÇÕES DE PAGINAÇÃO**
        
        // Atualizar informações da paginação
        function updatePaginationInfo(totalItems, totalPages) {
            const itemsInfo = document.getElementById('itemsInfo');
            const pageInfo = document.getElementById('pageInfo');
            
            if (totalItems === 0) {
                itemsInfo.textContent = 'Nenhum personagem encontrado';
                pageInfo.textContent = '';
            } else {
                const startItem = ((currentPage - 1) * itemsPerPage) + 1;
                const endItem = Math.min(currentPage * itemsPerPage, totalItems);
                itemsInfo.textContent = `Mostrando ${startItem}-${endItem} de ${totalItems} personagens`;
                pageInfo.textContent = `Página ${currentPage} de ${totalPages}`;
            }
        }
        
        // Renderizar controles de paginação
        function renderPaginationControls(totalPages) {
            const container = document.getElementById('paginationControls');
            container.innerHTML = '';
            
            if (totalPages <= 1) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'flex';
            
            // Botão Primeira Página
            if (currentPage > 1) {
                const firstBtn = createPaginationButton('❮❮', 1, 'Primeira página');
                container.appendChild(firstBtn);
            }
            
            // Botão Página Anterior
            if (currentPage > 1) {
                const prevBtn = createPaginationButton('❮', currentPage - 1, 'Página anterior');
                container.appendChild(prevBtn);
            }
            
            // Números das páginas
            const startPage = Math.max(1, currentPage - 2);
            const endPage = Math.min(totalPages, currentPage + 2);
            
            for (let i = startPage; i <= endPage; i++) {
                const pageBtn = createPaginationButton(i, i, `Página ${i}`, i === currentPage);
                container.appendChild(pageBtn);
            }
            
            // Botão Próxima Página
            if (currentPage < totalPages) {
                const nextBtn = createPaginationButton('❯', currentPage + 1, 'Próxima página');
                container.appendChild(nextBtn);
            }
            
            // Botão Última Página
            if (currentPage < totalPages) {
                const lastBtn = createPaginationButton('❯❯', totalPages, 'Última página');
                container.appendChild(lastBtn);
            }
        }
        
        // Criar botão de paginação
        function createPaginationButton(text, page, title, isActive = false) {
            const button = document.createElement('button');
            button.textContent = text;
            button.title = title;
            button.onclick = () => goToPage(page);
            
            button.style.cssText = `
                padding: 8px 12px;
                margin: 0 2px;
                border: 1px solid #dee2e6;
                background: ${isActive ? '#007bff' : 'white'};
                color: ${isActive ? 'white' : '#495057'};
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                min-width: 40px;
                transition: all 0.2s;
            `;
            
            if (!isActive) {
                button.addEventListener('mouseenter', function() {
                    this.style.background = '#e9ecef';
                });
                button.addEventListener('mouseleave', function() {
                    this.style.background = 'white';
                });
            }
            
            return button;
        }
        
        // Navegar para página específica
        function goToPage(page) {
            const totalPages = Math.ceil(Object.keys(filteredCharacters).length / itemsPerPage);
            
            if (page < 1 || page > totalPages) return;
            
            currentPage = page;
            renderTable(filteredCharacters, currentPage);
        }
        
        // **FUNÇÃO AUXILIAR**
        
        // Truncar texto com limite de caracteres
        function truncateText(text, maxLength = 10) {
            if (!text || text.length <= maxLength) {
                return text || 'N/A';
            }
            return text.substring(0, maxLength) + '...';
        }
        
        // **FUNÇÕES DE ALTERNAÇÃO DE LAYOUT**
        
        // Alternar entre visualização de cards e tabela
        function toggleViewMode() {
            const btn = document.getElementById('viewToggleBtn');
            const cardsContainer = document.getElementById('cardsContainer');
            const tableContainer = document.getElementById('tableContainer');
            
            if (viewMode === 'cards') {
                // Trocar para tabela
                viewMode = 'table';
                btn.innerHTML = 'Ver Cards';
                btn.style.background = '#6c757d'; // Cor padrão
                cardsContainer.style.display = 'none';
                tableContainer.style.display = 'block';
            } else {
                // Trocar para cards
                viewMode = 'cards';
                btn.innerHTML = 'Ver Tabela';
                btn.style.background = '#6c757d'; // Cor padrão
                cardsContainer.style.display = 'block';
                tableContainer.style.display = 'none';
            }
            
            // Re-renderizar com o novo layout
            renderTable(filteredCharacters, currentPage);
        }

        // **FUNÇÃO ATUALIZADA**: Excluir personagem (agora com ID string)
        async function deleteCharacter(id) {
            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }

            if (confirm(`Tem certeza que deseja excluir o personagem com ID: ${id}?`)) {
                try {
                    const response = await fetch(`${API_BASE}/characters/${id}`, {
                        method: 'DELETE'
                    });

                    const result = await response.json();
                    
                    if (result.success) {
                        showNotification(`✅ Personagem excluído automaticamente! (ID: ${id})`, 'success');
                        // Aguardar um momento para garantir que o backup e exclusão terminaram
                        setTimeout(() => loadCharacters(), 300);
                    } else {
                        showNotification('Erro ao excluir: ' + result.error, 'error');
                    }
                } catch (error) {
                    showNotification('Erro de conexão', 'error');
                }
            }
        }

        // **FUNÇÃO ATUALIZADA**: Filtrar personagens (incluindo busca por ID)
        // **FUNÇÃO ATUALIZADA**: Filtrar personagens com paginação
        function filterCharacters() {
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            
            if (!searchTerm) {
                // Se não há filtro, mostrar todos os personagens
                filteredCharacters = allCharacters;
            } else {
                // Filtrar personagens
                const filtered = {};
                
                Object.entries(allCharacters).forEach(([key, char]) => {
                    const matchesName = char.name.toLowerCase().includes(searchTerm);
                    const matchesId = char.id.toLowerCase().includes(searchTerm);
                    // Level search removido
                    
                    if (matchesName || matchesId) {
                        filtered[key] = char;
                    }
                });
                
                filteredCharacters = filtered;
            }
            
            // Resetar para primeira página após filtrar
            currentPage = 1;
            renderTable(filteredCharacters, currentPage);
        }

        // Download JS export
        async function downloadExport(type) {
            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }

            try {
                const url = `${API_BASE}/export/${type}`;
                const link = document.createElement('a');
                link.href = url;
                link.click();
                
                showNotification(`📥 Download iniciado: ${type.toUpperCase()} (com IDs HEX)`, 'info');
            } catch (error) {
                showNotification('Erro no download', 'error');
            }
        }

        // Atualizar tabela
        async function refreshTable() {
            showNotification('Atualizando dados...', 'info');
            await loadCharacters();
            showNotification('Dados atualizados!', 'success');
        }



        // Mostrar notificação
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            
            // Quebrar linhas se necessário
            notification.innerHTML = message.replace(/\n/g, '<br>');
            
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 5000);
        }

        // **NOVAS FUNÇÕES DE EDIÇÃO**
        
        // Abrir modal de edição
        async function editCharacter(id) {
            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }

            try {
                // Buscar dados do personagem
                const response = await fetch(`${API_BASE}/characters`);
                const data = await response.json();
                const character = data.characters[id];
                
                if (!character) {
                    showNotification('Personagem não encontrado!', 'error');
                    return;
                }

                // Preencher formulário de edição
                document.getElementById('editCharacterId').value = character.id;
                document.getElementById('editName').value = character.name;
                document.getElementById('editLevel').value = character.level;
                document.getElementById('editHp').value = character.hp;
                document.getElementById('editAttack').value = character.attack;
                document.getElementById('editAtaqueEspecial').value = character.ataque_especial || character.attack || 10;
                document.getElementById('editDefense').value = character.defense;
                document.getElementById('editDefesaEspecial').value = character.defesa_especial || 10;
                document.getElementById('editClasse').value = character.classe || '';
                document.getElementById('editCultura').value = character.cultura || '';
                
                document.getElementById('editSubclasse').value = character.subclasse || '';
                document.getElementById('editAnima').value = character.anima || 100;
                document.getElementById('editCritico').value = character.critico || 1.0;
                document.getElementById('editAiType').value = character.ai_type;
                document.getElementById('editDescription').value = character.description || '';

                // Carregar skills existentes do personagem
                await loadExistingSkills(character.skills || []);

                // RESET: Limpar dados de imagem de outros personagens antes de carregar o atual
                editCurrentImageData = null;
                originalSpriteFilename = null;
                
                // Limpar input de arquivo e preview
                document.getElementById('editSpriteInput').value = '';
                document.getElementById('editSpritePreview').style.display = 'none';
                document.getElementById('editRemoveFileBtn').style.display = 'none';
                
                // Armazenar informações da sprite original do personagem atual
                originalSpriteFilename = character.sprite ? character.sprite.split('/').pop() : null;
                
                // Preencher campo do nome do arquivo sprite
                document.getElementById('editSpriteFilename').value = originalSpriteFilename || '';
                
                // Mostrar sprite atual se existir
                const editSpritePreview = document.getElementById('editSpritePreview');
                const editFileText = document.getElementById('editFileText');
                const editFileIcon = document.getElementById('editFileIcon');
                
                if (character.sprite) {
                    const timestamp = new Date().getTime();
                    const spriteUrl = `http://localhost:3002/${character.sprite}?v=${timestamp}`;
                    
                    // Mostrar preview da sprite atual
                    editSpritePreview.innerHTML = `
                        <img src="${spriteUrl}" alt="Sprite atual" style="max-width: 100px; max-height: 100px; border-radius: 6px; image-rendering: pixelated;">
                        <div style="font-size: 12px; margin-top: 5px; font-weight: bold;">Sprite atual: ${originalSpriteFilename}</div>
                        <div style="font-size: 11px; color: #6c757d;">Clique para alterar ou manter a atual</div>
                    `;
                    editSpritePreview.style.display = 'block';
                    editFileText.style.display = 'none';
                    editFileIcon.style.display = 'none';
                } else {
                    editSpritePreview.style.display = 'none';
                    editFileText.style.display = 'block';
                    editFileIcon.style.display = 'block';
                    editFileText.innerHTML = `
                        <strong>Clique para fazer upload</strong><br>
                        ou arraste uma imagem aqui<br>
                        <small style="color: #666;">Nenhuma sprite atual</small>
                    `;
                }

                // Mostrar modal
                document.getElementById('editModal').classList.add('show');
                
            } catch (error) {
                console.error('Erro ao carregar personagem para edição:', error);
                showNotification('Erro ao carregar dados do personagem', 'error');
            }
        }

        // Trigger upload de imagem na edição
        function triggerEditImageUpload() {
            if (serverOnline) {
                document.getElementById('editSpriteInput').click();
            } else {
                showNotification('Servidor offline! Não é possível fazer upload.', 'error');
            }
        }

        // Fechar modal de edição
        function closeEditModal() {
            document.getElementById('editModal').classList.remove('show');
            // Limpar variáveis de edição
            editCurrentImageData = null;
            originalSpriteFilename = null;
            
            // Limpar formulário
            document.getElementById('editCharacterForm').reset();
            
            // Resetar área de upload
            const editSpritePreview = document.getElementById('editSpritePreview');
            const editFileText = document.getElementById('editFileText');
            const editFileIcon = document.getElementById('editFileIcon');
            const editRemoveBtn = document.getElementById('editRemoveFileBtn');
            
            editSpritePreview.style.display = 'none';
            editFileText.style.display = 'block';
            editFileIcon.style.display = 'block';
            editRemoveBtn.style.display = 'none';
            
            editFileText.innerHTML = `
                <strong>Clique para alterar sprite</strong><br>
                ou arraste uma nova imagem aqui<br>
            `;
            
            // Limpar container de skills
            const editSkillsContainer = document.getElementById('editSkillsContainer');
            editSkillsContainer.innerHTML = '<button type="button" class="add-btn" onclick="addEditSkill()">+ Adicionar Skill</button>';
        }

        // Manipular upload de imagem na edição
        function handleEditImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Verificar tipo de arquivo
            const validTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/gif', 'image/webp'];
            if (!validTypes.includes(file.type)) {
                showNotification('Formato de arquivo não suportado!', 'error');
                event.target.value = '';
                return;
            }

            // Verificar tamanho do arquivo (2MB)
            if (file.size > 2 * 1024 * 1024) {
                showNotification('❌ Arquivo muito grande! Máximo: 2MB', 'error');
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                editCurrentImageData = e.target.result;
                updateEditImagePreview(file);
                
                // Determinar nome do arquivo
                const spriteFilenameInput = document.getElementById('editSpriteFilename');
                let newFilename;
                
                if (originalSpriteFilename) {
                    // Manter o nome original se não foi especificado um novo
                    const originalExtension = originalSpriteFilename.split('.').pop().toLowerCase();
                    const newExtension = file.name.split('.').pop().toLowerCase();
                    
                    // Se usuario não especificou um nome, usar o original com a nova extensão
                    if (!spriteFilenameInput.value.trim() || spriteFilenameInput.value.trim() === originalSpriteFilename) {
                        const baseName = originalSpriteFilename.replace(`.${originalExtension}`, '');
                        newFilename = `${baseName}.${newExtension}`;
                        spriteFilenameInput.value = newFilename;
                    }
                } else {
                    // Gerar nome baseado no nome do personagem se não existe sprite original
                    const characterName = document.getElementById('editName').value.trim();
                    if (characterName && !spriteFilenameInput.value.trim()) {
                        const extension = file.name.split('.').pop().toLowerCase();
                        const suggestedName = `${characterName.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '')}.${extension}`;
                        spriteFilenameInput.value = suggestedName;
                    }
                }
                
                showNotification('🖼️ Nova sprite selecionada! Será aplicada ao salvar.', 'info');
            };
            reader.readAsDataURL(file);
        }

        // Atualizar preview da imagem na edição
        function updateEditImagePreview(file) {
            const editSpritePreview = document.getElementById('editSpritePreview');
            const editFileText = document.getElementById('editFileText');
            const editFileIcon = document.getElementById('editFileIcon');
            const editRemoveBtn = document.getElementById('editRemoveFileBtn');
            
            const sizeKB = Math.round(file.size / 1024);
            
            editSpritePreview.innerHTML = `
                <img src="${editCurrentImageData}" alt="Nova sprite" style="max-width: 100px; max-height: 100px; border-radius: 6px; image-rendering: pixelated;">
                <div style="font-size: 12px; margin-top: 5px; font-weight: bold; color: #28a745;">Nova sprite: ${file.name} (${sizeKB}KB)</div>
                <div style="font-size: 11px; color: #28a745; font-weight: bold;">✅ Pronta para substituir a anterior</div>
            `;
            
            editSpritePreview.style.display = 'block';
            editFileText.style.display = 'none';
            editFileIcon.style.display = 'none';
            editRemoveBtn.style.display = 'inline-block';
        }

        // Limpar arquivo sprite na edição
        function clearEditSpriteFile(event) {
            event.stopPropagation();
            
            editCurrentImageData = null;
            const editSpritePreview = document.getElementById('editSpritePreview');
            const editFileText = document.getElementById('editFileText');
            const editFileIcon = document.getElementById('editFileIcon');
            const editRemoveBtn = document.getElementById('editRemoveFileBtn');
            const input = document.getElementById('editSpriteInput');
            const spriteFilenameInput = document.getElementById('editSpriteFilename');
            
            input.value = '';
            
            // Resetar para mostrar sprite original se existir
            if (originalSpriteFilename) {
                const timestamp = new Date().getTime();
                const spriteUrl = `http://localhost:3002/assets/sprites/${originalSpriteFilename}?v=${timestamp}`;
                
                editSpritePreview.innerHTML = `
                    <img src="${spriteUrl}" alt="Sprite atual" style="max-width: 100px; max-height: 100px; border-radius: 6px; image-rendering: pixelated;">
                    <div style="font-size: 12px; margin-top: 5px; font-weight: bold;">Sprite atual: ${originalSpriteFilename}</div>
                    <div style="font-size: 11px; color: #6c757d;">Clique para alterar ou manter a atual</div>
                `;
                editSpritePreview.style.display = 'block';
                editFileText.style.display = 'none';
                editFileIcon.style.display = 'none';
                spriteFilenameInput.value = originalSpriteFilename;
            } else {
                editSpritePreview.style.display = 'none';
                editFileText.style.display = 'block';
                editFileIcon.style.display = 'block';
                editFileText.innerHTML = `
                    <strong>Clique para fazer upload</strong><br>
                    ou arraste uma imagem aqui<br>
                    <small style="color: #666;">Nenhuma sprite atual</small>
                `;
                spriteFilenameInput.value = '';
            }
            
            editRemoveBtn.style.display = 'none';
        }

        // Submeter edição de personagem
        document.getElementById('editCharacterForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }

            const formData = new FormData(this);
            const characterId = formData.get('id');
            
            // Adicionar dados da sprite se uma nova foi selecionada
            if (editCurrentImageData) {
                // Upload da nova sprite primeiro
                try {
                    showNotification('🖼️ Fazendo upload da nova sprite...', 'info');
                    
                    const spriteFilenameInput = document.getElementById('editSpriteFilename');
                    let spriteFilename = spriteFilenameInput.value.trim();
                    
                    // Se não especificado, usar nome original ou gerar baseado no nome do personagem
                    if (!spriteFilename) {
                        if (originalSpriteFilename) {
                            const newExtension = editCurrentImageData.split(',')[0].match(/data:image\/(\w+)/)[1];
                            const baseName = originalSpriteFilename.replace(/\.[^.]+$/, '');
                            spriteFilename = `${baseName}.${newExtension}`;
                        } else {
                            const characterName = document.getElementById('editName').value.trim();
                            const newExtension = editCurrentImageData.split(',')[0].match(/data:image\/(\w+)/)[1];
                            spriteFilename = `${characterName.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '')}.${newExtension}`;
                        }
                    }

                    const spriteResponse = await fetch(`${API_BASE}/upload-sprite`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            imageData: editCurrentImageData,
                            filename: spriteFilename,
                            replaceExisting: true // Flag para substituir arquivo existente
                        })
                    });

                    const spriteResult = await spriteResponse.json();
                    
                    if (!spriteResult.success) {
                        showNotification('❌ Erro ao fazer upload da sprite: ' + spriteResult.error, 'error');
                        return;
                    }
                    
                    // Adicionar caminho da sprite ao formData
                    formData.set('spriteFilename', spriteFilename);
                    showNotification('✅ Sprite enviada com sucesso!', 'success');
                    
                } catch (error) {
                    showNotification('❌ Erro ao fazer upload da sprite', 'error');
                    console.error('Erro no upload da sprite:', error);
                    return;
                }
            } else {
                // Se não há nova sprite, mas o nome foi alterado, renomear o arquivo existente
                const spriteFilenameInput = document.getElementById('editSpriteFilename');
                const newFilename = spriteFilenameInput.value.trim();
                
                if (newFilename && originalSpriteFilename && newFilename !== originalSpriteFilename) {
                    try {
                        showNotification('📝 Renomeando arquivo sprite...', 'info');
                        
                        const renameResponse = await fetch(`${API_BASE}/rename-sprite`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                oldFilename: originalSpriteFilename,
                                newFilename: newFilename
                            })
                        });

                        const renameResult = await renameResponse.json();
                        
                        if (!renameResult.success) {
                            showNotification('❌ Erro ao renomear sprite: ' + renameResult.error, 'error');
                            return;
                        }
                        
                        // Adicionar o novo nome ao formData para atualizar o personagem
                        formData.set('spriteFilename', newFilename);
                        showNotification('✅ Sprite renomeada com sucesso!', 'success');
                        
                    } catch (error) {
                        showNotification('❌ Erro ao renomear sprite', 'error');
                        console.error('Erro no renomeamento da sprite:', error);
                        return;
                    }
                } else if (newFilename && originalSpriteFilename && newFilename === originalSpriteFilename) {
                    // Nome não foi alterado, apenas manter
                    formData.set('spriteFilename', newFilename);
                }
            }

            // Processar skills editadas
            const editedSkills = processEditedSkills();
            if (editedSkills.length > 0) {
                formData.set('skills', JSON.stringify(editedSkills));
            }

            try {
                showNotification('💾 Atualizando personagem...', 'info');

                const response = await fetch(`${API_BASE}/characters/${characterId}`, {
                    method: 'PUT',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    let message = `✅ ${result.message}`;
                    if (result.sprite_updated) {
                        message += `\n🖼️ Sprite atualizada: ${result.sprite_path || 'mantida'}`;
                    }
                    showNotification(message, 'success');
                    
                    closeEditModal();
                    // Aguardar um momento para garantir que o servidor terminou de salvar
                    setTimeout(() => loadCharacters(), 300);
                } else {
                    showNotification('❌ Erro ao atualizar: ' + result.error, 'error');
                }

            } catch (error) {
                console.error('Erro ao atualizar personagem:', error);
                showNotification('❌ Erro de conexão ao atualizar personagem', 'error');
            }
        });

        // Fechar modal clicando no overlay
        document.getElementById('editModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeEditModal();
            }
        });

        // **FUNÇÕES DE IMPORTAÇÃO/EXPORTAÇÃO EM MASSA**

        // Abrir modal de importação em massa
        function openBulkImportModal() {
            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }
            document.getElementById('bulkImportModal').classList.add('show');
        }

        // Fechar modal de importação em massa
        function closeBulkImportModal() {
            document.getElementById('bulkImportModal').classList.remove('show');
            // Reset form
            document.getElementById('bulkImportForm').reset();
            document.getElementById('bulkImportPreview').innerHTML = '📁 Clique para selecionar arquivo JSON';
            document.getElementById('bulkImportSubmitBtn').disabled = true;
            document.getElementById('bulkImportProgress').style.display = 'none';
            document.getElementById('bulkImportResults').style.display = 'none';
        }

        // Manipular seleção de arquivo para importação em massa
        function handleBulkImportFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Verificar se é JSON
            if (!file.name.endsWith('.json')) {
                showNotification('❌ Apenas arquivos JSON são aceitos!', 'error');
                event.target.value = '';
                return;
            }

            // Verificar tamanho (10MB)
            if (file.size > 10 * 1024 * 1024) {
                showNotification('❌ Arquivo muito grande! Máximo: 10MB', 'error');
                event.target.value = '';
                return;
            }

            // Mostrar preview do arquivo
            const preview = document.getElementById('bulkImportPreview');
            const fileSize = (file.size / 1024 / 1024).toFixed(2);
            preview.innerHTML = `
                <div style="text-align: center;">
                    📄 <strong>${file.name}</strong><br>
                    <small>Tamanho: ${fileSize} MB</small>
                </div>
            `;

            // Habilitar botão de importar
            document.getElementById('bulkImportSubmitBtn').disabled = false;
            showNotification('✅ Arquivo JSON selecionado!', 'success');
        }

        // Exportação em massa
        async function bulkExportCharacters() {
            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }

            try {
                showNotification('📤 Iniciando exportação em massa...', 'info');
                
                // Fazer download direto
                const link = document.createElement('a');
                link.href = `${API_BASE}/bulk-export`;
                link.download = 'bulk_characters_export.json';
                link.click();
                
                showNotification('✅ Exportação em massa iniciada! Verifique os downloads.', 'success');
                
            } catch (error) {
                showNotification('❌ Erro na exportação em massa', 'error');
                console.error('Erro na exportação:', error);
            }
        }

        // Submeter importação em massa
        document.getElementById('bulkImportForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }

            const fileInput = document.getElementById('bulkImportFile');
            if (!fileInput.files[0]) {
                showNotification('❌ Selecione um arquivo JSON primeiro!', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('bulkData', fileInput.files[0]);

            // Mostrar progresso
            const progressDiv = document.getElementById('bulkImportProgress');
            const progressBar = document.getElementById('bulkImportProgressBar');
            const progressText = document.getElementById('bulkImportProgressText');
            const resultsDiv = document.getElementById('bulkImportResults');
            
            progressDiv.style.display = 'block';
            resultsDiv.style.display = 'none';
            progressBar.style.width = '0%';
            progressText.textContent = 'Enviando arquivo...';

            try {
                // Simular progresso durante upload
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += 10;
                    if (progress <= 90) {
                        progressBar.style.width = progress + '%';
                        progressText.textContent = `Processando... ${progress}%`;
                    }
                }, 200);

                const response = await fetch(`${API_BASE}/bulk-import`, {
                    method: 'POST',
                    body: formData
                });

                clearInterval(progressInterval);
                progressBar.style.width = '100%';
                progressText.textContent = 'Processamento concluído!';

                const result = await response.json();

                if (result.success) {
                    // Mostrar resultados
                    displayBulkImportResults(result.summary);
                    // Aguardar um momento para garantir que o backup e importação terminaram
                    setTimeout(() => loadCharacters(), 500);
                    showNotification(`✅ ${result.message}`, 'success');
                } else {
                    showNotification('❌ Erro na importação: ' + result.error, 'error');
                    progressDiv.style.display = 'none';
                }

            } catch (error) {
                console.error('Erro na importação:', error);
                showNotification('❌ Erro de conexão na importação em massa', 'error');
                progressDiv.style.display = 'none';
            }
        });

        // Exibir resultados da importação
        function displayBulkImportResults(summary) {
            const resultsDiv = document.getElementById('bulkImportResults');
            const summaryDiv = document.getElementById('bulkImportSummary');
            const detailsDiv = document.getElementById('bulkImportDetails');

            // Resumo
            summaryDiv.innerHTML = `
                <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <strong>📋 Resumo:</strong><br>
                    • Total no arquivo: <span style="color: #1565c0;">${summary.total}</span><br>
                    • Importados: <span style="color: #28a745;">${summary.imported}</span><br>
                    • Conflitos resolvidos: <span style="color: #f57c00;">${summary.conflicts}</span><br>
                    • Ignorados: <span style="color: #dc3545;">${summary.skipped}</span>
                </div>
            `;

            // Detalhes por personagem
            let detailsHtml = '<h5>📝 Detalhes por Personagem:</h5><div style="max-height: 200px; overflow-y: auto;">';
            summary.results.forEach(result => {
                let statusColor = '#28a745'; // green
                let statusIcon = '✅';
                
                if (result.status === 'conflict_resolved') {
                    statusColor = '#f57c00'; // orange
                    statusIcon = '🔄';
                } else if (result.status === 'skipped' || result.status === 'error') {
                    statusColor = '#dc3545'; // red  
                    statusIcon = '❌';
                }

                detailsHtml += `
                    <div style="padding: 5px; border-bottom: 1px solid #eee;">
                        ${statusIcon} <strong>${result.name}</strong> (ID: ${result.id}${result.newId ? ' → ' + result.newId : ''})<br>
                        <small style="color: ${statusColor};">${result.reason}</small>
                    </div>
                `;
            });
            detailsHtml += '</div>';
            
            detailsDiv.innerHTML = detailsHtml;
            resultsDiv.style.display = 'block';
        }

        // Fechar modal clicando no overlay
        document.getElementById('bulkImportModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeBulkImportModal();
            }
        });

        // Inicializar aplicação
        // **NOVO**: Sistema de Backup - Funções JavaScript

        // Abrir modal de backup
        function openBackupModal() {
            document.getElementById('backupModal').classList.add('show');
            loadBackupList();
        }

        // Fechar modal de backup
        function closeBackupModal() {
            document.getElementById('backupModal').classList.remove('show');
        }

        // Criar backup manual
        async function createManualBackup() {
            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }

            const btn = document.getElementById('createBackupBtn');
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Criando backup...';

            try {
                const response = await fetch(`${API_BASE}/backup`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (data.success) {
                    showNotification(`✅ Backup criado: ${data.filename} (${data.characters} personagens)`, 'success');
                    // Aguardar um momento para garantir que o backup foi salvo no disco
                    setTimeout(() => loadBackupList(), 300);
                } else {
                    showNotification('❌ Erro ao criar backup: ' + data.error, 'error');
                }
            } catch (error) {
                showNotification('❌ Erro ao criar backup', 'error');
                console.error('Erro:', error);
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        // Carregar lista de backups
        async function loadBackupList(retries = 3) {
            if (!serverOnline) {
                document.getElementById('backupList').innerHTML = '<div style="text-align: center; color: #dc3545; padding: 20px;">Servidor offline</div>';
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/backups`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();

                if (data.success && data.backups.length > 0) {
                    renderBackupList(data.backups);
                } else {
                    document.getElementById('backupList').innerHTML = '<div style="text-align: center; color: #6c757d; padding: 20px;">Nenhum backup encontrado</div>';
                }
            } catch (error) {
                console.error('Erro ao carregar backups:', error);
                
                // Tentar novamente se ainda temos tentativas
                if (retries > 0) {
                    console.log(`Tentando carregar backups novamente... (${retries} tentativas restantes)`);
                    setTimeout(() => loadBackupList(retries - 1), 500);
                } else {
                    document.getElementById('backupList').innerHTML = '<div style="text-align: center; color: #dc3545; padding: 20px;">Erro ao carregar backups</div>';
                }
            }
        }

        // Renderizar lista de backups
        function renderBackupList(backups) {
            const container = document.getElementById('backupList');
            let html = '';

            backups.forEach(backup => {
                const date = new Date(backup.timestamp).toLocaleString('pt-BR');
                const triggerIcon = backup.trigger === 'manual' ? '👤' : '🤖';
                const triggerText = backup.trigger === 'manual' ? 'Manual' : 'Automático';
                const sizeKB = Math.round(backup.size / 1024);
                
                // Indicador de sprites
                const spriteInfo = backup.includes_sprites ? 
                    `🖼️ ${backup.sprites || 0} sprites` : 
                    '⚠️ Sem sprites';
                
                const backupTypeIcon = backup.includes_sprites ? '📦' : '📄';

                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid #dee2e6; border-radius: 6px; margin-bottom: 8px; background: white;">
                        <div style="flex-grow: 1;">
                            <div style="font-weight: bold; margin-bottom: 4px;">
                                ${backupTypeIcon} ${triggerIcon} ${backup.filename}
                            </div>
                            <div style="font-size: 12px; color: #6c757d;">
                                📅 ${date} • ${triggerText} • ${backup.characters} personagens • ${spriteInfo} • ${sizeKB}KB
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-primary btn-small" onclick="restoreFromBackup('${backup.filename}')">
                                🔄 Restaurar
                            </button>
                            <button class="btn btn-danger btn-small" onclick="deleteBackup('${backup.filename}')">
                                🗑️ Excluir
                            </button>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Restaurar do backup
        async function restoreFromBackup(filename) {
            if (!confirm(`⚠️ ATENÇÃO: Restaurar substituirá todos os personagens atuais pelos dados do backup.\n\nDeseja continuar?`)) {
                return;
            }

            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }

            try {
                showNotification('🔄 Restaurando backup...', 'info');
                
                const response = await fetch(`${API_BASE}/restore/${filename}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (data.success) {
                    const message = data.includes_sprites ? 
                        `✅ Restaurado: ${data.characters} personagens, ${data.sprites} sprites` :
                        `✅ Restaurado: ${data.characters} personagens (backup sem sprites)`;
                    showNotification(message, 'success');
                    // Aguardar um momento para garantir que a restauração terminou
                    setTimeout(() => {
                        loadCharacters();
                        closeBackupModal();
                    }, 500);
                } else {
                    showNotification('❌ Erro ao restaurar: ' + data.error, 'error');
                }
            } catch (error) {
                showNotification('❌ Erro ao restaurar backup', 'error');
                console.error('Erro:', error);
            }
        }

        // Excluir backup
        async function deleteBackup(filename) {
            if (!confirm(`Tem certeza que deseja excluir o backup:\n${filename}?`)) {
                return;
            }

            if (!serverOnline) {
                showNotification('Servidor offline!', 'error');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/backup/${filename}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    showNotification('🗑️ Backup excluído com sucesso', 'success');
                    // Aguardar um momento para garantir que o arquivo foi removido do disco
                    setTimeout(() => loadBackupList(), 300);
                } else {
                    showNotification('❌ Erro ao excluir backup', 'error');
                }
            } catch (error) {
                showNotification('❌ Erro ao excluir backup', 'error');
                console.error('Erro:', error);
            }
        }

        // Fechar modal de backup ao clicar fora
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('backupModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeBackupModal();
                }
            });
        });

        async function initApp() {
            await checkServerStatus();
            await loadClasses(); // Carregar classes disponíveis
            setInterval(checkServerStatus, 30000); // Verificar a cada 30s
            
            // Configurar event listeners para os selects de classe
            document.getElementById('classe').addEventListener('change', function() {
                handleClassSelection(this);
            });
            
            document.getElementById('editClasse').addEventListener('change', function() {
                handleClassSelection(this);
            });
            
            // Configurar drag and drop para a área de edição de sprite
            const editUploadContainer = document.getElementById('editSpriteContainer');
            
            editUploadContainer.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (serverOnline) {
                    editUploadContainer.classList.add('dragover');
                }
            });

            editUploadContainer.addEventListener('dragleave', function(e) {
                e.preventDefault();
                editUploadContainer.classList.remove('dragover');
            });

            editUploadContainer.addEventListener('drop', function(e) {
                e.preventDefault();
                editUploadContainer.classList.remove('dragover');
                
                if (!serverOnline) {
                    showNotification('Servidor offline! Não é possível fazer upload.', 'error');
                    return;
                }

                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    
                    // Simular input change event
                    const editSpriteInput = document.getElementById('editSpriteInput');
                    
                    // Criar um novo FileList com o arquivo
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    editSpriteInput.files = dt.files;
                    
                    // Processar o arquivo
                    handleEditImageUpload({ target: { files: [file] } });
                }
            });
        }




        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>