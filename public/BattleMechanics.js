/**
 * Battle Mechanics Domain Service - Browser Version
 * 
 * Implementa todas as mec√¢nicas de combate do RPGStack v3.3.0
 * incluindo sistema de vantagens de classes, defesa, medita√ß√£o
 * e c√°lculo de dano com atributo cr√≠tico.
 * 
 * Features:
 * - Sistema de vantagens de classes (pedra-papel-tesoura)
 * - Mec√¢nica de defesa (imunidade a dano n√£o-cr√≠tico)
 * - Sistema de medita√ß√£o (recupera√ß√£o HP/√Çnima)
 * - C√°lculo de dano com atributo cr√≠tico
 * - Estados de batalha por turno
 * - Cad√™ncia do Drag√£o (Lutador)
 * - Arsenal Adaptativo (Armamentista)
 * - Converg√™ncia √Çnima (Arcano)
 */

class BattleMechanics {
  /**
   * Tabela de vantagens de classes
   * Lutador > Armamentista > Arcano > Lutador
   */
  static CLASS_ADVANTAGES = {
    'Lutador': 'Armamentista',
    'Armamentista': 'Arcano',
    'Arcano': 'Lutador'
  };

  /**
   * Modificadores de vantagem
   */
  static ADVANTAGE_DAMAGE_BONUS = 1.10; // +10% de dano
  static ADVANTAGE_DAMAGE_REDUCTION = 0.90; // -10% de dano recebido

  /**
   * Valores de recupera√ß√£o da medita√ß√£o
   */
  static MEDITATION_ANIMA_RECOVERY = 0.10; // 10% do √Çnima m√°ximo
  static MEDITATION_HP_RECOVERY = 0.05; // 5% da vida m√°xima
  
  // ARCANO IMMORTALITY SYSTEM - Converg√™ncia √Çnima v2.2.0 BALANCED
  static ARCANO_MEDITATION_HP_RECOVERY = 0.50; // 50% HP para Arcanos com Converg√™ncia √Çnima
  static ARCANO_MEDITATION_ANIMA_RECOVERY = 0.25; // 25% √Çnima para Arcanos com Converg√™ncia √Çnima

  /**
   * Estados de batalha
   */
  constructor() {
    this.battleStates = new Map(); // Armazena estados por ID do personagem
    this.skillStates = new Map(); // Armazena estados espec√≠ficos de skills
  }

  /**
   * Verifica se atacante tem vantagem de classe sobre o defensor
   * @param {string} attackerClass - Classe do atacante
   * @param {string} defenderClass - Classe do defensor
   * @returns {boolean} True se tem vantagem
   */
  hasAdvantage(attackerClass, defenderClass) {
    return BattleMechanics.CLASS_ADVANTAGES[attackerClass] === defenderClass;
  }

  /**
   * Aplica modificadores de vantagem de classe no dano
   * @param {number} damage - Dano base
   * @param {string} attackerClass - Classe do atacante
   * @param {string} defenderClass - Classe do defensor
   * @returns {number} Dano modificado
   */
  applyClassModifiers(damage, attackerClass, defenderClass) {
    let modifiedDamage = damage;

    // Aplicar b√¥nus de dano se atacante tem vantagem
    if (this.hasAdvantage(attackerClass, defenderClass)) {
      modifiedDamage *= BattleMechanics.ADVANTAGE_DAMAGE_BONUS;
    }

    // Aplicar redu√ß√£o de dano se defensor tem vantagem
    if (this.hasAdvantage(defenderClass, attackerClass)) {
      modifiedDamage *= BattleMechanics.ADVANTAGE_DAMAGE_REDUCTION;
    }

    return Math.round(modifiedDamage);
  }

  /**
   * Calcula dano de ataque b√°sico
   * @param {Object} attacker - Personagem atacante
   * @param {Object} defender - Personagem defensor
   * @returns {number} Dano calculado
   */
  calculateBasicAttackDamage(attacker, defender) {
    // F√≥rmula: (ATK - (DEF * 0.7)) * critico
    let damage = attacker.attack - (defender.defense * 0.7);
    
    // Aplicar modificador cr√≠tico
    damage *= (attacker.critico || 1.0);
    
    // Aplicar modificadores de classe
    damage = this.applyClassModifiers(damage, attacker.classe, defender.classe);
    
    return Math.max(0, Math.round(damage));
  }

  /**
   * Calcula dano de habilidade
   * @param {Object} attacker - Personagem atacante
   * @param {Object} defender - Personagem defensor
   * @param {Object} skill - Habilidade usada
   * @returns {number} Dano calculado
   */
  calculateSkillDamage(attacker, defender, skill) {
    // F√≥rmula: ((ATK * (skill.damage / 10)) - (DEF * 0.5)) * critico
    const skillPower = skill.damage || 0;
    let damage = (attacker.attack * (skillPower / 10)) - (defender.defense * 0.5);
    
    // Aplicar modificador cr√≠tico
    damage *= (attacker.critico || 1.0);
    
    // Aplicar modificadores de classe
    damage = this.applyClassModifiers(damage, attacker.classe, defender.classe);
    
    return Math.max(0, Math.round(damage));
  }

  /**
   * Define estado de defesa para um personagem
   * @param {string} characterId - ID do personagem
   * @param {boolean} defending - Se est√° defendendo
   */
  setDefending(characterId, defending) {
    if (!this.battleStates.has(characterId)) {
      this.battleStates.set(characterId, {});
    }
    this.battleStates.get(characterId).defending = defending;
  }

  /**
   * Verifica se personagem est√° defendendo
   * @param {string} characterId - ID do personagem
   * @returns {boolean} True se est√° defendendo
   */
  isDefending(characterId) {
    const state = this.battleStates.get(characterId);
    return state ? state.defending || false : false;
  }

  /**
   * Verifica se um ataque √© cr√≠tico
   * @returns {boolean} True se √© cr√≠tico
   */
  isCriticalHit() {
    return false; // Por enquanto sempre false
  }

  /**
   * Aplica mec√¢nica de defesa no dano
   * @param {number} damage - Dano original
   * @param {string} defenderId - ID do defensor
   * @returns {number} Dano final ap√≥s defesa
   */
  applyDefense(damage, defenderId) {
    if (this.isDefending(defenderId) && !this.isCriticalHit()) {
      return 0; // Imune a dano n√£o-cr√≠tico
    }
    return damage;
  }

  /**
   * Executa medita√ß√£o para um personagem
   * @param {Object} character - Personagem que ir√° meditar
   * @returns {Object} Resultado da medita√ß√£o
   */
  meditate(character) {
    const maxAnima = character.anima || 100;
    let animaRecovered, hpRecovered, newAnima, newHp, message;
    
    // ARCANO IMMORTALITY SYSTEM - Converg√™ncia √Çnima v2.2.0
    if (character.classe === 'Arcano') {
      // Verificar se tem Converg√™ncia √Çnima ativa
      const hasConvergencia = character.skills && character.skills.some(skill => 
        skill.skillId === '9BC8DEF6G1' || skill.skillName?.includes('Converg√™ncia √Çnima')
      );
      
      if (hasConvergencia) {
        // BALANCED RESTORATION para Arcanos com Converg√™ncia √Çnima
        animaRecovered = Math.round(maxAnima * BattleMechanics.ARCANO_MEDITATION_ANIMA_RECOVERY);
        hpRecovered = Math.round(character.maxHP * BattleMechanics.ARCANO_MEDITATION_HP_RECOVERY);
        newAnima = Math.min(character.currentAnima + animaRecovered, maxAnima);
        newHp = Math.min(character.currentHP + hpRecovered, character.maxHP);
        
        // Marcar como meditando para prote√ß√£o contra instant kill
        character.isMeditating = true;
        character.meditationActive = true;
        
        message = `üõ°Ô∏è CONVERG√äNCIA √ÇNIMA: Medita√ß√£o balanceada! Restaurou ${hpRecovered} HP (50%) e ${animaRecovered} √Çnima (25%). PROTEGIDO contra instant kill cr√≠tico!`;
      } else {
        // Arcano sem Converg√™ncia √Çnima - medita√ß√£o normal
        animaRecovered = Math.round(maxAnima * BattleMechanics.MEDITATION_ANIMA_RECOVERY);
        hpRecovered = Math.round(character.maxHP * BattleMechanics.MEDITATION_HP_RECOVERY);
        newAnima = Math.min(character.currentAnima + animaRecovered, maxAnima);
        newHp = Math.min(character.currentHP + hpRecovered, character.maxHP);
        message = `Medita√ß√£o conclu√≠da! Recuperou ${hpRecovered} HP e ${animaRecovered} √Çnima.`;
      }
    } else {
      // Outras classes - medita√ß√£o normal
      animaRecovered = Math.round(maxAnima * BattleMechanics.MEDITATION_ANIMA_RECOVERY);
      hpRecovered = Math.round(character.maxHP * BattleMechanics.MEDITATION_HP_RECOVERY);
      newAnima = Math.min(character.currentAnima + animaRecovered, maxAnima);
      newHp = Math.min(character.currentHP + hpRecovered, character.maxHP);
      message = `Medita√ß√£o conclu√≠da! Recuperou ${hpRecovered} HP e ${animaRecovered} √Çnima.`;
    }
    
    // MEDITATION COUNTER para Arcanos
    let meditationCounterState = null;
    let convergenciaInstantKill = false;
    
    if (character.classe === 'Arcano') {
      // Verificar se era a 5¬™ medita√ß√£o ANTES de processar
      const previousState = this.getMeditationCounterState(character.id);
      const isConvergenciaInstantKill = previousState.sessionMeditations === 5;
      
      meditationCounterState = this.processMeditationCounter(character.id);
      
      // Se era a 6¬™ medita√ß√£o (ap√≥s 5), ativar instant kill
      if (isConvergenciaInstantKill) {
        convergenciaInstantKill = true;
        message += ' üíÄ CONVERG√äNCIA √ÇNIMA: INSTANT KILL ATIVADO!';
      }
    }

    return {
      animaRecovered,
      hpRecovered,
      newAnima,
      newHp,
      success: true,
      message,
      isArcanoImmortal: character.classe === 'Arcano' && character.isMeditating,
      meditationCounter: meditationCounterState,
      convergenciaInstantKill: convergenciaInstantKill
    };
  }

  /**
   * Reset estados de batalha para um novo turno
   * @param {string} characterId - ID do personagem (opcional)
   */
  resetTurnStates(characterId = null) {
    if (characterId) {
      if (this.battleStates.has(characterId)) {
        this.battleStates.get(characterId).defending = false;
      }
    } else {
      for (const [id, state] of this.battleStates) {
        state.defending = false;
      }
    }
  }

  /**
   * Obter informa√ß√µes sobre vantagens de classe
   * @param {string} attackerClass - Classe do atacante
   * @param {string} defenderClass - Classe do defensor
   * @returns {Object} Informa√ß√µes sobre vantagens
   */
  getClassAdvantageInfo(attackerClass, defenderClass) {
    const attackerHasAdvantage = this.hasAdvantage(attackerClass, defenderClass);
    const defenderHasAdvantage = this.hasAdvantage(defenderClass, attackerClass);
    
    return {
      attackerHasAdvantage,
      defenderHasAdvantage,
      attackerModifier: attackerHasAdvantage ? BattleMechanics.ADVANTAGE_DAMAGE_BONUS : 1.0,
      defenderModifier: defenderHasAdvantage ? BattleMechanics.ADVANTAGE_DAMAGE_REDUCTION : 1.0,
      advantageText: attackerHasAdvantage 
        ? `${attackerClass} tem vantagem sobre ${defenderClass}!`
        : defenderHasAdvantage 
        ? `${defenderClass} tem vantagem sobre ${attackerClass}!`
        : 'Nenhuma vantagem de classe.'
    };
  }

  // ============= CAD√äNCIA DO DRAG√ÉO (Lutador) =============
  
  /**
   * Processar ataque b√°sico para Cad√™ncia do Drag√£o
   * @param {string} characterId - ID do personagem
   * @returns {Object} Estado atual da cad√™ncia
   */
  processDragonCadence(characterId, baseAttack = 50) {
    if (!this.skillStates.has(characterId)) {
      this.skillStates.set(characterId, {
        dragonCadence: {
          consecutiveBasicAttacks: 0,
          currentBuff: 0,
          totalAttackBonus: 0,
          isActive: false,
          skillActivated: false,
          baseAttack: baseAttack
        }
      });
    }

    const skillState = this.skillStates.get(characterId).dragonCadence;
    
    // Atualizar base attack se fornecido
    if (baseAttack && baseAttack !== skillState.baseAttack) {
      skillState.baseAttack = baseAttack;
    }
    
    // S√≥ processa se a skill foi ativada
    if (!skillState.skillActivated) {
      return {
        consecutiveAttacks: 0,
        currentBuff: 0,
        appliedBuff: 0,
        attackBonus: 0,
        message: `üêâ Cad√™ncia do Drag√£o est√° inativa. Use a skill para ativar o estado aprimorado!`
      };
    }
    
    // NOVO ALGORITMO v6.0.0: +10% do attack base por ataque consecutivo
    skillState.consecutiveBasicAttacks++;
    const attackBonus = Math.round(skillState.baseAttack * 0.10 * skillState.consecutiveBasicAttacks);
    skillState.totalAttackBonus = attackBonus;
    skillState.currentBuff = skillState.consecutiveBasicAttacks * 10; // Para UI (percentual)
    
    console.log('üêâ REWORK v6.0.0 DEBUG:', {
      characterId,
      baseAttack: skillState.baseAttack,
      consecutiveAttacks: skillState.consecutiveBasicAttacks,
      attackBonus,
      percentualBuff: skillState.currentBuff
    });
    
    return {
      consecutiveAttacks: skillState.consecutiveBasicAttacks,
      currentBuff: skillState.currentBuff,
      appliedBuff: skillState.currentBuff,
      attackBonus: attackBonus,
      totalAttack: skillState.baseAttack + attackBonus,
      message: `üêâ REWORK v6.0.0! Attack: ${skillState.baseAttack} ‚Üí ${skillState.baseAttack + attackBonus} (+${attackBonus} pontos)`
    };
  }

  /**
   * Ativar a Cad√™ncia do Drag√£o (usar a skill para entrar em estado aprimorado)
   * @param {string} characterId - ID do personagem
   * @returns {Object} Estado ap√≥s ativa√ß√£o
   */
  activateDragonCadence(characterId) {
    console.log('üîß BattleMechanics.activateDragonCadence chamado para:', characterId);
    
    if (!this.skillStates.has(characterId)) {
      console.log('üîß Criando novo skillState para:', characterId);
      this.skillStates.set(characterId, {
        dragonCadence: {
          consecutiveBasicAttacks: 0,
          currentBuff: 0,
          isActive: false,
          skillActivated: false
        }
      });
    }

    const skillState = this.skillStates.get(characterId).dragonCadence;
    console.log('üîß Estado antes da ativa√ß√£o:', skillState);
    
    // Ativar o estado aprimorado
    skillState.skillActivated = true;
    skillState.isActive = true;
    skillState.consecutiveBasicAttacks = 0;
    skillState.currentBuff = 0;
    
    console.log('üîß Estado ap√≥s ativa√ß√£o:', skillState);
    
    const result = {
      activated: true,
      message: `üêâ CAD√äNCIA DO DRAG√ÉO v6.0.0 ATIVADA! Personagem entrou em estado aprimorado. Cada ataque b√°sico aumentar√° o poder de attack!`
    };
    
    console.log('üîß Retornando resultado:', result);
    return result;
  }

  /**
   * Quebrar sequ√™ncia da Cad√™ncia do Drag√£o
   * @param {string} characterId - ID do personagem
   * @returns {Object} Estado ap√≥s quebra
   */
  breakDragonCadence(characterId) {
    console.log('üîß BattleMechanics.breakDragonCadence chamado para:', characterId);
    
    if (!this.skillStates.has(characterId)) {
      console.log('üîß Nenhum skillState encontrado para:', characterId);
      return { broken: false, currentBuff: 0 };
    }

    const skillState = this.skillStates.get(characterId).dragonCadence;
    console.log('üîß Estado antes do break:', skillState);
    
    // Resetar contador mas manter skill ativa (n√£o quebra mais o estado aprimorado)
    skillState.consecutiveBasicAttacks = 0;
    skillState.currentBuff = 0;
    
    console.log('üîß Estado ap√≥s break (mant√©m isActive):', skillState);
    
    return {
      broken: true,
      currentBuff: 0,
      message: `üêâ Sequ√™ncia de ataques resetada! Estado aprimorado continua ativo. Pr√≥ximo ataque b√°sico come√ßar√° do +10% novamente.`
    };
  }

  /**
   * Aplicar buff da Cad√™ncia do Drag√£o no dano
   * @param {number} baseDamage - Dano base
   * @param {string} characterId - ID do personagem
   * @returns {number} Dano modificado
   */
  applyDragonCadenceBuff(baseDamage, characterId) {
    const cadenceState = this.getDragonCadenceState(characterId);
    if (!cadenceState.isActive || cadenceState.currentBuff === 0) {
      return baseDamage;
    }

    const buffMultiplier = 1 + (cadenceState.currentBuff / 100);
    return Math.round(baseDamage * buffMultiplier);
  }

  /**
   * Obter estado atual da Cad√™ncia do Drag√£o
   * @param {string} characterId - ID do personagem
   * @returns {Object} Estado atual
   */
  getDragonCadenceState(characterId) {
    // DEBUG: Log do estado interno do skill
    console.log('üîç BattleMechanics DEBUG - getDragonCadenceState:', {
      characterId,
      hasSkillStates: this.skillStates.has(characterId),
      skillStatesSize: this.skillStates.size,
      allCharacterIds: Array.from(this.skillStates.keys())
    });
    
    if (!this.skillStates.has(characterId) || !this.skillStates.get(characterId).dragonCadence) {
      console.log('üêâ Nenhum estado de Cad√™ncia encontrado para:', characterId);
      return { isActive: false, currentBuff: 0, consecutiveAttacks: 0 };
    }

    const skillState = this.skillStates.get(characterId).dragonCadence;
    const result = {
      isActive: skillState.isActive,
      currentBuff: skillState.currentBuff,
      consecutiveAttacks: skillState.consecutiveBasicAttacks,
      lastCalculation: skillState.lastCalculation,
      sequenceBroken: skillState.sequenceBroken
    };
    
    console.log('üêâ Estado da Cad√™ncia encontrado:', result);
    return result;
  }

  // ============= ARSENAL ADAPTATIVO (Armamentista) =============

  /**
   * Processar a√ß√£o para Arsenal Adaptativo
   * @param {string} characterId - ID do personagem
   * @param {string} actionType - Tipo da a√ß√£o
   * @returns {Object} Estado atual
   */
  processArsenalAdaptativo(characterId, actionType) {
    if (!this.skillStates.has(characterId)) {
      this.skillStates.set(characterId, {});
    }
    
    if (!this.skillStates.get(characterId).arsenalAdaptativo) {
      this.skillStates.get(characterId).arsenalAdaptativo = {
        lastActionType: null,
        consecutiveAlternations: 0,
        currentBuff: 0,
        isActive: true
      };
    }

    const skillState = this.skillStates.get(characterId).arsenalAdaptativo;

    if (skillState.lastActionType === null) {
      skillState.lastActionType = actionType;
      return {
        actionType,
        isAlternation: false,
        consecutiveAlternations: 0,
        currentBuff: 0,
        message: `Arsenal Adaptativo: Primeira a√ß√£o (${actionType}).`
      };
    }

    const isAlternation = skillState.lastActionType !== actionType;
    
    if (isAlternation) {
      const appliedBuff = actionType === 'defense' ? 0 : skillState.currentBuff;
      skillState.consecutiveAlternations++;
      const nextBuff = skillState.consecutiveAlternations * 3;
      skillState.lastActionType = actionType;
      skillState.currentBuff = nextBuff;
      
      return {
        actionType,
        isAlternation: true,
        consecutiveAlternations: skillState.consecutiveAlternations,
        currentBuff: nextBuff,
        appliedBuff: appliedBuff,
        message: `Arsenal Adaptativo: Altern√¢ncia ${skillState.consecutiveAlternations}! ${actionType === 'defense' ? 'Defesa n√£o ganha b√¥nus.' : `A√ß√£o ganha +${appliedBuff}% de efetividade.`}`
      };
    } else {
      skillState.consecutiveAlternations = 0;
      skillState.currentBuff = 0;
      skillState.lastActionType = actionType;
      
      return {
        actionType,
        isAlternation: false,
        consecutiveAlternations: 0,
        currentBuff: 0,
        message: `Arsenal Adaptativo: Mesma a√ß√£o repetida. Contador zerado.`
      };
    }
  }

  // ============= CONVERG√äNCIA √ÇNIMA (Arcano) =============

  /**
   * Processar skill com √¢nima para Converg√™ncia √Çnima
   * @param {string} characterId - ID do personagem
   * @param {number} animaCost - Custo de √¢nima
   * @returns {Object} Estado atual
   */
  processConvergenciaAnima(characterId, animaCost = 0) {
    if (!this.skillStates.has(characterId)) {
      this.skillStates.set(characterId, {});
    }
    
    if (!this.skillStates.get(characterId).convergenciaAnima) {
      this.skillStates.get(characterId).convergenciaAnima = {
        consecutiveAnimaSkills: 0,
        currentReduction: 0,
        isActive: true
      };
    }

    const skillState = this.skillStates.get(characterId).convergenciaAnima;

    if (animaCost > 0) {
      skillState.consecutiveAnimaSkills++;
      const newReduction = skillState.consecutiveAnimaSkills * 2;
      const appliedReduction = skillState.currentReduction;
      const reductionMultiplier = 1 - (appliedReduction / 100);
      const effectiveCost = Math.max(0, Math.round(animaCost * reductionMultiplier));
      
      skillState.currentReduction = newReduction;
      
      return {
        consecutiveAnimaSkills: skillState.consecutiveAnimaSkills,
        currentReduction: skillState.currentReduction,
        originalCost: animaCost,
        effectiveCost: effectiveCost,
        savedAnima: animaCost - effectiveCost,
        message: `Converg√™ncia √Çnima: ${skillState.consecutiveAnimaSkills} skills consecutivas. Redu√ß√£o: ${appliedReduction}%. Custo: ${animaCost} ‚Üí ${effectiveCost} √¢nima`
      };
    }

    return {
      consecutiveAnimaSkills: skillState.consecutiveAnimaSkills,
      currentReduction: skillState.currentReduction,
      originalCost: animaCost,
      effectiveCost: animaCost,
      savedAnima: 0,
      message: `Skill n√£o consome √¢nima.`
    };
  }

  /**
   * Calcular custo efetivo de √¢nima
   * @param {number} baseCost - Custo base
   * @param {string} characterId - ID do personagem
   * @returns {number} Custo efetivo
   */
  calculateEffectiveAnimaCost(baseCost, characterId) {
    if (baseCost === 0) return 0;

    const convergenciaState = this.getConvergenciaAnimaState(characterId);
    if (!convergenciaState.isActive || convergenciaState.currentReduction === 0) {
      return baseCost;
    }

    const reductionMultiplier = 1 - (convergenciaState.currentReduction / 100);
    return Math.max(0, Math.round(baseCost * reductionMultiplier));
  }

  /**
   * Obter estado da Converg√™ncia √Çnima
   * @param {string} characterId - ID do personagem
   * @returns {Object} Estado atual
   */
  getConvergenciaAnimaState(characterId) {
    if (!this.skillStates.has(characterId) || !this.skillStates.get(characterId).convergenciaAnima) {
      return { isActive: false, currentReduction: 0, consecutiveAnimaSkills: 0 };
    }

    const skillState = this.skillStates.get(characterId).convergenciaAnima;
    return {
      isActive: skillState.isActive,
      currentReduction: skillState.currentReduction,
      consecutiveAnimaSkills: skillState.consecutiveAnimaSkills
    };
  }

  // ============= MEDITATION COUNTER SYSTEM (Arcano) =============

  /**
   * Processar medita√ß√£o para Arcanos com contador
   * @param {string} characterId - ID do personagem
   * @returns {Object} Estado atual do contador de medita√ß√£o
   */
  processMeditationCounter(characterId) {
    if (!this.skillStates.has(characterId)) {
      this.skillStates.set(characterId, {});
    }
    
    if (!this.skillStates.get(characterId).meditationCounter) {
      this.skillStates.get(characterId).meditationCounter = {
        totalMeditations: 0,
        sessionMeditations: 0,
        consecutiveMeditations: 0,
        lastMeditationTurn: 0,
        isActive: true
      };
    }

    const meditationState = this.skillStates.get(characterId).meditationCounter;
    
    // Incrementar contadores
    meditationState.totalMeditations++;
    meditationState.sessionMeditations++;
    meditationState.consecutiveMeditations++;
    meditationState.lastMeditationTurn = Date.now();

    console.log('üßò MeditationCounter - Processed:', {
      characterId,
      totalMeditations: meditationState.totalMeditations,
      sessionMeditations: meditationState.sessionMeditations,
      consecutiveMeditations: meditationState.consecutiveMeditations
    });

    // Verificar se pr√≥xima medita√ß√£o (6¬™) causar√° instant kill
    const willCauseInstantKill = meditationState.sessionMeditations === 5;
    const hasArmamentistaCounter = meditationState.sessionMeditations >= 5;
    
    return {
      totalMeditations: meditationState.totalMeditations,
      sessionMeditations: meditationState.sessionMeditations,
      consecutiveMeditations: meditationState.consecutiveMeditations,
      isActive: meditationState.isActive,
      hasArmamentistaCounter: hasArmamentistaCounter,
      willCauseInstantKill: willCauseInstantKill,
      message: `üßò Medita√ß√µes: ${meditationState.totalMeditations} total, ${meditationState.sessionMeditations} nesta batalha${willCauseInstantKill ? ' üíÄ PR√ìXIMA MEDITA√á√ÉO = INSTANT KILL!' : hasArmamentistaCounter ? ' ‚öîÔ∏è CONVERG√äNCIA ATIVA!' : ''}`
    };
  }

  /**
   * Reset contador de medita√ß√µes consecutivas
   * @param {string} characterId - ID do personagem
   */
  resetConsecutiveMeditations(characterId) {
    if (this.skillStates.has(characterId) && this.skillStates.get(characterId).meditationCounter) {
      this.skillStates.get(characterId).meditationCounter.consecutiveMeditations = 0;
      console.log('üßò MeditationCounter - Reset consecutive meditations for:', characterId);
    }
  }

  /**
   * Obter estado atual do contador de medita√ß√£o
   * @param {string} characterId - ID do personagem
   * @returns {Object} Estado atual
   */
  getMeditationCounterState(characterId) {
    console.log('üßò getMeditationCounterState DEBUG:', {
      characterId,
      hasSkillStates: this.skillStates.has(characterId),
      skillStatesKeys: Array.from(this.skillStates.keys())
    });

    if (!this.skillStates.has(characterId) || !this.skillStates.get(characterId).meditationCounter) {
      console.log('üßò No meditation state found, returning default');
      return {
        totalMeditations: 0,
        sessionMeditations: 0,
        consecutiveMeditations: 0,
        isActive: false
      };
    }

    const meditationState = this.skillStates.get(characterId).meditationCounter;
    console.log('üßò Found meditation state:', meditationState);
    
    return {
      totalMeditations: meditationState.totalMeditations,
      sessionMeditations: meditationState.sessionMeditations,
      consecutiveMeditations: meditationState.consecutiveMeditations,
      isActive: meditationState.isActive
    };
  }

  /**
   * Reset contador de sess√£o (para nova batalha)
   * @param {string} characterId - ID do personagem
   */
  resetSessionMeditations(characterId) {
    if (this.skillStates.has(characterId) && this.skillStates.get(characterId).meditationCounter) {
      this.skillStates.get(characterId).meditationCounter.sessionMeditations = 0;
      this.skillStates.get(characterId).meditationCounter.consecutiveMeditations = 0;
      console.log('üßò MeditationCounter - Reset session for:', characterId);
    }
  }

  /**
   * Verificar se Arcano pode dar instant kill em Armamentista (5+ medita√ß√µes)
   * @param {string} arcanoId - ID do Arcano atacante
   * @param {Object} target - Alvo do ataque
   * @returns {Object} Resultado da verifica√ß√£o
   */
  checkArcanoArmamentistaCounter(arcanoId, target) {
    const meditationState = this.getMeditationCounterState(arcanoId);
    const canInstantKill = meditationState.sessionMeditations >= 5 && target.classe === 'Armamentista';
    
    console.log('‚öîÔ∏è ArcanoCounter - DEBUG COMPLETO:', {
      arcanoId,
      targetClass: target.classe,
      targetName: target.name,
      sessionMeditations: meditationState.sessionMeditations,
      meditationState: meditationState,
      canInstantKill,
      isTargetArmamentista: target.classe === 'Armamentista',
      hasEnoughMeditations: meditationState.sessionMeditations >= 5
    });

    return {
      canInstantKill,
      meditationCount: meditationState.sessionMeditations,
      targetClass: target.classe,
      message: canInstantKill 
        ? `‚öîÔ∏è COUNTER ATIVO: Arcano (${meditationState.sessionMeditations} medita√ß√µes) vs Armamentista = INSTANT KILL GARANTIDO!`
        : meditationState.sessionMeditations >= 5 
          ? `‚öîÔ∏è Counter ativo mas alvo n√£o √© Armamentista (${target.classe})`
          : `üßò Medita√ß√µes insuficientes: ${meditationState.sessionMeditations}/5 para counter`
    };
  }
}

// Tornar dispon√≠vel globalmente
window.BattleMechanics = BattleMechanics;