<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste Sistema de Dano em √Årea - Personagens da Reserva</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .success { color: green; font-weight: bold; }
        .error { color: red; font-weight: bold; }
        .warning { color: orange; font-weight: bold; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 3px; }
        .passed { background-color: #e8f5e8; }
        .failed { background-color: #ffeaea; }
        .area-demo { 
            padding: 20px; 
            border: 2px solid #ff6b35; 
            border-radius: 10px; 
            background-color: #fff5f0;
            margin: 10px 0;
        }
        .damage-display { 
            background-color: #ffe0b3; 
            padding: 15px; 
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        .team-display { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 10px; 
            margin: 10px 0; 
        }
        .character { 
            padding: 15px; 
            border: 2px solid #999; 
            border-radius: 8px; 
            background-color: #f9f9f9; 
            text-align: center;
            position: relative;
        }
        .active { background-color: #c8e6c9; border-color: #4CAF50; font-weight: bold; }
        .reserve { background-color: #fff3e0; border-color: #FF9800; }
        .damaged { background-color: #ffcdd2; border-color: #f44336; animation: damage-flash 1s ease-out; }
        .defeated { background-color: #e0e0e0; border-color: #9e9e9e; opacity: 0.6; }
        
        @keyframes damage-flash {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); background-color: #ff5722; }
            100% { transform: scale(1); }
        }
        
        .damage-indicator {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #f44336;
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            animation: damage-pop 0.5s ease-out;
        }
        
        @keyframes damage-pop {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        button { margin: 5px; padding: 10px; font-size: 14px; }
        .big-button { padding: 15px 30px; font-size: 16px; font-weight: bold; }
        .skill-button { 
            padding: 12px 20px; 
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .fire-skill { background-color: #ff5722; color: white; }
        .ice-skill { background-color: #2196F3; color: white; }
        .physical-skill { background-color: #795548; color: white; }
        .thunder-skill { background-color: #9C27B0; color: white; }
        
        pre { background-color: #f5f5f5; padding: 10px; border-radius: 3px; font-size: 12px; }
    </style>
</head>
<body>
    <h1>üî• Teste do Sistema de Dano em √Årea - Reserva 3v3</h1>
    
    <div id="test-results"></div>
    
    <div class="test-section">
        <h3>Demonstra√ß√£o Visual de Dano em √Årea</h3>
        <div id="area-demo" class="area-demo">
            <div><strong>Estado:</strong> <span id="demo-status">Aguardando Inicializa√ß√£o</span></div>
            <div><strong>√öltima Skill:</strong> <span id="last-skill">Nenhuma</span></div>
            <div><strong>Dano Total:</strong> <span id="total-damage">0</span></div>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
            <button class="big-button" onclick="initializeAreaDemo()">Inicializar Demonstra√ß√£o</button>
            <button onclick="resetDemo()">Reset Teams</button>
            <button onclick="healAllCharacters()">Curar Todos</button>
        </div>
        
        <div id="skill-buttons" style="display: none; text-align: center; margin: 15px 0;">
            <h4>Skills de √Årea Dispon√≠veis:</h4>
            <button class="skill-button fire-skill" onclick="useAreaSkill('explosao_fogo')">Explos√£o de Fogo (Foco)</button>
            <button class="skill-button ice-skill" onclick="useAreaSkill('tempestade_gelo')">Tempestade de Gelo (√Årea Fixa)</button>
            <button class="skill-button physical-skill" onclick="useAreaSkill('onda_choque')">Onda de Choque (Decrescente)</button>
            <button class="skill-button thunder-skill" onclick="useAreaSkill('chuva_flechas')">Chuva de Flechas (√Årea)</button>
        </div>
        
        <div id="teams-visual" style="display: none;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div>
                    <h4>üõ°Ô∏è Equipe Jogador</h4>
                    <div id="player-team" class="team-display"></div>
                </div>
                <div>
                    <h4>‚öîÔ∏è Equipe Inimigo</h4>
                    <div id="enemy-team" class="team-display"></div>
                </div>
            </div>
        </div>
        
        <div id="damage-log" class="damage-display" style="display: none;">
            <h4>Log de Dano:</h4>
            <div id="damage-entries"></div>
        </div>
    </div>

    <div class="test-section">
        <h3>Testes Automatizados</h3>
        <button onclick="runAreaDamageTests()">Executar Testes de √Årea</button>
        <button onclick="testDamageFormulas()">Testar F√≥rmulas de Dano</button>
        <button onclick="testReserveProtection()">Testar Prote√ß√£o de Reserva</button>
        <button onclick="simulateAreaBattle()">Simular Batalha AoE Completa</button>
    </div>

    <script src="battlemechanics.js"></script>
    <script>
        let battleMechanics;
        let testResults = [];
        let demoInitialized = false;
        let damageHistory = [];
        
        // Dados de teste para batalha 3v3
        const demoPlayerTeam = [
            { name: "Tank", hp: 400, maxHp: 400, attack: 120, defense: 150, id: "player_tank" },
            { name: "Mago DPS", hp: 220, maxHp: 220, attack: 90, specialAttack: 200, spirit: 80, id: "player_mage" },
            { name: "Assassino", hp: 180, maxHp: 180, attack: 180, defense: 60, id: "player_assassin" }
        ];
        
        const demoEnemyTeam = [
            { name: "Orc Chefe", hp: 350, maxHp: 350, attack: 140, defense: 120, id: "enemy_orc" },
            { name: "Shaman", hp: 200, maxHp: 200, attack: 80, specialAttack: 170, spirit: 100, id: "enemy_shaman" },
            { name: "Berserker", hp: 250, maxHp: 250, attack: 160, defense: 80, id: "enemy_berserker" }
        ];

        function runTest(testName, testFunction, expectedToPass = true) {
            try {
                const result = testFunction();
                if (expectedToPass) {
                    testResults.push({ name: testName, result: 'PASSOU', details: result, type: 'success' });
                    console.log(`‚úì ${testName}: PASSOU`);
                } else {
                    testResults.push({ name: testName, result: 'FALHOU (esperava erro)', details: 'N√£o deveria ter passado', type: 'failed' });
                    console.error(`‚úó ${testName}: FALHOU - Esperava que falhasse mas passou`);
                }
                return true;
            } catch (error) {
                if (expectedToPass) {
                    testResults.push({ name: testName, result: 'FALHOU', details: error.message, type: 'failed' });
                    console.error(`‚úó ${testName}: FALHOU - ${error.message}`);
                } else {
                    testResults.push({ name: testName, result: 'PASSOU (erro esperado)', details: error.message, type: 'success' });
                    console.log(`‚úì ${testName}: PASSOU (erro esperado) - ${error.message}`);
                }
                return false;
            }
        }

        function test1_InitializeAreaSystem() {
            battleMechanics = new BattleMechanics();
            battleMechanics.initialize3v3Battle(demoPlayerTeam, demoEnemyTeam);
            
            if (!battleMechanics.processAreaAttack) {
                throw new Error('M√©todo processAreaAttack n√£o encontrado');
            }
            
            if (!battleMechanics.calculateAreaDamage) {
                throw new Error('M√©todo calculateAreaDamage n√£o encontrado');
            }
            
            if (!battleMechanics.getAreaSkillConfig) {
                throw new Error('M√©todo getAreaSkillConfig n√£o encontrado');
            }
            
            return 'Sistema de dano em √°rea inicializado com todos os m√©todos';
        }

        function test2_TestAreaSkillConfigs() {
            const skills = ['tempestade_gelo', 'explosao_fogo', 'onda_choque', 'chuva_flechas'];
            let configCount = 0;
            
            skills.forEach(skill => {
                const config = battleMechanics.getAreaSkillConfig(skill);
                if (config && config.type && config.skillMultiplier && config.baseDamage !== undefined) {
                    configCount++;
                } else {
                    throw new Error(`Configura√ß√£o inv√°lida para skill: ${skill}`);
                }
            });
            
            return `${configCount} configura√ß√µes de skills de √°rea validadas`;
        }

        function test3_TestAreaDamageCalculation() {
            const attacker = { name: "Test", attack: 150, specialAttack: 180 };
            const target = { name: "Target", defense: 100, spirit: 90, hp: 200, maxHp: 200 };
            
            const physicalConfig = {
                type: 'area_fixa',
                reducer: 0.6,
                skillMultiplier: 2.0,
                baseDamage: 30,
                isSpecialAttack: false
            };
            
            const magicalConfig = {
                type: 'area_fixa',
                reducer: 0.6,
                skillMultiplier: 2.2,
                baseDamage: 45,
                isSpecialAttack: true
            };
            
            const physicalResult = battleMechanics.calculateAreaDamage(attacker, target, physicalConfig, true);
            const magicalResult = battleMechanics.calculateAreaDamage(attacker, target, magicalConfig, true);
            
            if (physicalResult.damage <= 0 || magicalResult.damage <= 0) {
                throw new Error('C√°lculos de dano resultaram em valores inv√°lidos');
            }
            
            return `Dano f√≠sico: ${physicalResult.damage}, Dano m√°gico: ${magicalResult.damage}`;
        }

        function test4_TestReserveProtection() {
            const attacker = { name: "Attacker", attack: 150, specialAttack: 180 };
            const target = { name: "Target", defense: 80, spirit: 70, hp: 200, maxHp: 200 };
            
            const config = {
                type: 'area_fixa',
                reducer: 0.6,
                skillMultiplier: 2.0,
                baseDamage: 40,
                includeReserves: true
            };
            
            const activeDamage = battleMechanics.calculateAreaDamage(attacker, target, config, true);
            const reserveDamage = battleMechanics.calculateAreaDamage(attacker, target, config, false);
            
            if (reserveDamage.damage >= activeDamage.damage) {
                throw new Error('Personagens da reserva deveriam receber menos dano');
            }
            
            const expectedReduction = reserveDamage.appliedModifiers.reserveProtection;
            if (expectedReduction !== 0.8) {
                throw new Error(`Prote√ß√£o de reserva incorreta: ${expectedReduction}, esperado 0.8`);
            }
            
            return `Ativo: ${activeDamage.damage}, Reserva: ${reserveDamage.damage} (prote√ß√£o 20%)`;
        }

        function test5_TestFullAreaAttack() {
            battleMechanics.battleState.isActive = true;
            
            const result = battleMechanics.processAreaAttack('player', {
                type: 'area_fixa',
                reducer: 0.6,
                skillMultiplier: 2.0,
                baseDamage: 35,
                isSpecialAttack: false
            });
            
            if (!result || !result.results) {
                throw new Error('Resultado do ataque em √°rea inv√°lido');
            }
            
            if (result.results.length !== 3) {
                throw new Error(`Esperado 3 alvos, recebido ${result.results.length}`);
            }
            
            let activeTargets = 0;
            let reserveTargets = 0;
            
            result.results.forEach(target => {
                if (target.isActive) activeTargets++;
                else reserveTargets++;
            });
            
            if (activeTargets !== 1 || reserveTargets !== 2) {
                throw new Error(`Alvos incorretos: ${activeTargets} ativo, ${reserveTargets} reserva`);
            }
            
            return `Ataque em √°rea: ${result.totalDamage} dano total, ${result.totalTargets} alvos`;
        }

        function test6_TestAreaTypes() {
            battleMechanics.battleState.isActive = true;
            
            const areaTypes = ['area_fixa', 'area_com_foco', 'area_decrescente'];
            let typeResults = [];
            
            areaTypes.forEach(type => {
                const result = battleMechanics.processAreaAttack('player', {
                    type: type,
                    skillMultiplier: 1.8,
                    baseDamage: 25
                });
                
                typeResults.push({
                    type: type,
                    totalDamage: result.totalDamage,
                    targets: result.totalTargets
                });
            });
            
            return `Tipos testados: ${typeResults.map(t => `${t.type}(${t.totalDamage})`).join(', ')}`;
        }

        function initializeAreaDemo() {
            try {
                battleMechanics = new BattleMechanics();
                battleMechanics.initialize3v3Battle([...demoPlayerTeam], [...demoEnemyTeam]);
                battleMechanics.battleState.isActive = true;
                
                demoInitialized = true;
                
                updateDemoStatus('Sistema 3v3 inicializado - Pronto para ataques em √°rea!');
                updateTeamsVisual();
                
                document.getElementById('skill-buttons').style.display = 'block';
                document.getElementById('teams-visual').style.display = 'block';
                document.getElementById('damage-log').style.display = 'block';
                
                console.log('Demonstra√ß√£o de √°rea iniciada!');
                
            } catch (error) {
                updateDemoStatus(`Erro: ${error.message}`);
                console.error('Erro ao inicializar demo:', error);
            }
        }

        function useAreaSkill(skillType) {
            if (!demoInitialized) {
                alert('Inicialize a demonstra√ß√£o primeiro!');
                return;
            }
            
            try {
                const skillConfig = battleMechanics.getAreaSkillConfig(skillType);
                const result = battleMechanics.processAreaAttack('player', skillConfig);
                
                // Atualizar display
                updateDemoStatus(`${skillType.replace('_', ' ').toUpperCase()} executada!`);
                document.getElementById('last-skill').textContent = skillType.replace('_', ' ');
                document.getElementById('total-damage').textContent = result.totalDamage;
                
                // Adicionar ao hist√≥rico
                damageHistory.push({
                    skill: skillType,
                    timestamp: new Date().toLocaleTimeString(),
                    totalDamage: result.totalDamage,
                    results: result.results
                });
                
                updateDamageLog();
                updateTeamsVisual();
                addDamageIndicators(result.results);
                
                console.log(`${skillType} executada:`, result);
                
            } catch (error) {
                updateDemoStatus(`Erro ao executar ${skillType}: ${error.message}`);
                console.error('Erro na skill:', error);
            }
        }

        function updateDemoStatus(message) {
            document.getElementById('demo-status').textContent = message;
        }

        function updateTeamsVisual() {
            if (!battleMechanics || !battleMechanics.battleState.teams) return;
            
            const playerTeamDiv = document.getElementById('player-team');
            const enemyTeamDiv = document.getElementById('enemy-team');
            
            const playerTeam = battleMechanics.battleState.teams.player;
            const enemyTeam = battleMechanics.battleState.teams.enemy;
            
            playerTeamDiv.innerHTML = playerTeam.characters.map((char, index) => {
                const isActive = index === playerTeam.activeIndex;
                const hpPercentage = (char.hp / char.maxHp) * 100;
                const statusClass = char.hp <= 0 ? 'defeated' : (isActive ? 'active' : 'reserve');
                
                return `
                    <div class="character ${statusClass}" id="player-${index}">
                        <strong>${char.name}</strong><br>
                        <div style="font-size: 12px; margin: 5px 0;">
                            HP: ${char.hp}/${char.maxHp}<br>
                            (${Math.round(hpPercentage)}%)
                        </div>
                        <div style="background-color: #ddd; height: 4px; border-radius: 2px;">
                            <div style="background-color: ${hpPercentage > 50 ? '#4CAF50' : hpPercentage > 25 ? '#FF9800' : '#f44336'}; 
                                        height: 100%; width: ${hpPercentage}%; border-radius: 2px;"></div>
                        </div>
                        <div style="font-size: 10px; margin-top: 2px;">
                            ${isActive ? '‚öîÔ∏è ATIVO' : 'üõ°Ô∏è RESERVA'}
                        </div>
                    </div>
                `;
            }).join('');
            
            enemyTeamDiv.innerHTML = enemyTeam.characters.map((char, index) => {
                const isActive = index === enemyTeam.activeIndex;
                const hpPercentage = (char.hp / char.maxHp) * 100;
                const statusClass = char.hp <= 0 ? 'defeated' : (isActive ? 'active' : 'reserve');
                
                return `
                    <div class="character ${statusClass}" id="enemy-${index}">
                        <strong>${char.name}</strong><br>
                        <div style="font-size: 12px; margin: 5px 0;">
                            HP: ${char.hp}/${char.maxHp}<br>
                            (${Math.round(hpPercentage)}%)
                        </div>
                        <div style="background-color: #ddd; height: 4px; border-radius: 2px;">
                            <div style="background-color: ${hpPercentage > 50 ? '#4CAF50' : hpPercentage > 25 ? '#FF9800' : '#f44336'}; 
                                        height: 100%; width: ${hpPercentage}%; border-radius: 2px;"></div>
                        </div>
                        <div style="font-size: 10px; margin-top: 2px;">
                            ${isActive ? '‚öîÔ∏è ATIVO' : 'üõ°Ô∏è RESERVA'}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function addDamageIndicators(results) {
            results.forEach(result => {
                const elementId = `enemy-${result.targetIndex}`;
                const element = document.getElementById(elementId);
                
                if (element) {
                    // Adicionar classe de dano
                    element.classList.add('damaged');
                    setTimeout(() => element.classList.remove('damaged'), 1000);
                    
                    // Adicionar indicador de dano
                    const indicator = document.createElement('div');
                    indicator.className = 'damage-indicator';
                    indicator.textContent = result.damage;
                    element.appendChild(indicator);
                    
                    setTimeout(() => {
                        if (indicator.parentNode) {
                            indicator.parentNode.removeChild(indicator);
                        }
                    }, 2000);
                }
            });
        }

        function updateDamageLog() {
            const logDiv = document.getElementById('damage-entries');
            
            const entries = damageHistory.slice(-5).reverse().map(entry => {
                const resultText = entry.results.map(r => 
                    `${r.target}(${r.isActive ? 'A' : 'R'}): ${r.damage}${r.isCritical ? '!' : ''}`
                ).join(', ');
                
                return `
                    <div style="margin: 5px 0; padding: 5px; background-color: #f0f0f0; border-radius: 3px;">
                        <strong>[${entry.timestamp}] ${entry.skill.replace('_', ' ').toUpperCase()}</strong><br>
                        <small>Total: ${entry.totalDamage} | ${resultText}</small>
                    </div>
                `;
            }).join('');
            
            logDiv.innerHTML = entries || '<em>Nenhuma skill de √°rea usada ainda...</em>';
        }

        function resetDemo() {
            if (!demoInitialized) return;
            
            // Resetar HP de todos os personagens
            battleMechanics.battleState.teams.player.characters.forEach(char => {
                char.hp = char.maxHp;
                char.currentHP = char.maxHp;
            });
            
            battleMechanics.battleState.teams.enemy.characters.forEach(char => {
                char.hp = char.maxHp;
                char.currentHP = char.maxHp;
            });
            
            damageHistory = [];
            updateDemoStatus('Equipes resetadas - HP restaurado');
            document.getElementById('last-skill').textContent = 'Nenhuma';
            document.getElementById('total-damage').textContent = '0';
            updateTeamsVisual();
            updateDamageLog();
        }

        function healAllCharacters() {
            resetDemo();
        }

        function runAreaDamageTests() {
            console.log('=== INICIANDO TESTES DE DANO EM √ÅREA ===');
            testResults = [];
            
            runTest('1. Inicializar Sistema de √Årea', test1_InitializeAreaSystem, true);
            runTest('2. Configura√ß√µes de Skills de √Årea', test2_TestAreaSkillConfigs, true);
            runTest('3. C√°lculo de Dano em √Årea', test3_TestAreaDamageCalculation, true);
            runTest('4. Prote√ß√£o de Personagens na Reserva', test4_TestReserveProtection, true);
            runTest('5. Ataque em √Årea Completo', test5_TestFullAreaAttack, true);
            runTest('6. Tipos de √Årea Diferentes', test6_TestAreaTypes, true);
            
            displayResults();
            
            console.log('=== TESTES DE √ÅREA CONCLU√çDOS ===');
        }

        function testDamageFormulas() {
            if (!battleMechanics) {
                battleMechanics = new BattleMechanics();
                battleMechanics.initialize3v3Battle([...demoPlayerTeam], [...demoEnemyTeam]);
            }
            
            console.log('=== TESTANDO F√ìRMULAS DE DANO ===');
            
            const attacker = { attack: 200, specialAttack: 180, name: "TestAttacker" };
            const tankTarget = { defense: 150, spirit: 80, hp: 400, maxHp: 400, name: "Tank" };
            const glassCannon = { defense: 50, spirit: 60, hp: 150, maxHp: 150, name: "GlassCannon" };
            
            const testSkills = ['tempestade_gelo', 'explosao_fogo', 'onda_choque'];
            
            testSkills.forEach(skill => {
                const config = battleMechanics.getAreaSkillConfig(skill);
                
                const tankDamage = battleMechanics.calculateAreaDamage(attacker, tankTarget, config, true);
                const glassDamage = battleMechanics.calculateAreaDamage(attacker, glassCannon, config, true);
                const reserveTankDamage = battleMechanics.calculateAreaDamage(attacker, tankTarget, config, false);
                
                console.log(`\n${skill.toUpperCase()}:`);
                console.log(`  Tank (Ativo): ${tankDamage.damage} dano`);
                console.log(`  Tank (Reserva): ${reserveTankDamage.damage} dano`);
                console.log(`  Glass Cannon: ${glassDamage.damage} dano`);
                console.log(`  Modificadores:`, tankDamage.appliedModifiers);
            });
            
            alert('F√≥rmulas testadas! Veja o console para detalhes.');
        }

        function testReserveProtection() {
            if (!demoInitialized) {
                initializeAreaDemo();
                setTimeout(testReserveProtection, 500);
                return;
            }
            
            console.log('=== TESTE DE PROTE√á√ÉO DA RESERVA ===');
            
            const originalHPs = {};
            battleMechanics.battleState.teams.enemy.characters.forEach((char, index) => {
                originalHPs[index] = char.hp;
            });
            
            // Executar ataque em √°rea
            const result = battleMechanics.processAreaAttack('player', {
                type: 'area_fixa',
                reducer: 0.6,
                skillMultiplier: 2.0,
                baseDamage: 50,
                includeReserves: true
            });
            
            const activeTarget = result.results.find(r => r.isActive);
            const reserveTargets = result.results.filter(r => !r.isActive);
            
            console.log('Resultado do Teste de Prote√ß√£o:');
            console.log(`Personagem Ativo recebeu: ${activeTarget.damage} dano`);
            reserveTargets.forEach((target, index) => {
                console.log(`Reserva ${index + 1} (${target.target}) recebeu: ${target.damage} dano`);
            });
            
            const averageReserveDamage = reserveTargets.reduce((sum, t) => sum + t.damage, 0) / reserveTargets.length;
            const protectionPercentage = ((activeTarget.damage - averageReserveDamage) / activeTarget.damage * 100).toFixed(1);
            
            console.log(`Prote√ß√£o m√©dia da reserva: ${protectionPercentage}%`);
            
            updateTeamsVisual();
            alert(`Teste conclu√≠do! Reserva recebeu ${protectionPercentage}% menos dano que o ativo.`);
        }

        function simulateAreaBattle() {
            if (!demoInitialized) {
                initializeAreaDemo();
                setTimeout(simulateAreaBattle, 1000);
                return;
            }
            
            console.log('=== SIMULANDO BATALHA COM ATAQUES EM √ÅREA ===');
            
            const areaSkills = ['explosao_fogo', 'tempestade_gelo', 'onda_choque', 'chuva_flechas'];
            let turn = 0;
            const maxTurns = 8;
            
            function executeTurn() {
                if (turn >= maxTurns) {
                    console.log('Simula√ß√£o de batalha conclu√≠da!');
                    updateDemoStatus('Simula√ß√£o conclu√≠da - Veja o log de dano');
                    return;
                }
                
                const randomSkill = areaSkills[Math.floor(Math.random() * areaSkills.length)];
                const attacker = turn % 2 === 0 ? 'player' : 'enemy';
                
                try {
                    const skillConfig = battleMechanics.getAreaSkillConfig(randomSkill);
                    const result = battleMechanics.processAreaAttack(attacker, skillConfig);
                    
                    console.log(`Turno ${turn + 1}: ${attacker} usa ${randomSkill} - ${result.totalDamage} dano total`);
                    
                    damageHistory.push({
                        skill: `${randomSkill} (${attacker})`,
                        timestamp: new Date().toLocaleTimeString(),
                        totalDamage: result.totalDamage,
                        results: result.results
                    });
                    
                    updateDamageLog();
                    updateTeamsVisual();
                    updateDemoStatus(`Turno ${turn + 1}: ${randomSkill} (${result.totalDamage} dano)`);
                    
                    turn++;
                    setTimeout(executeTurn, 2000);
                    
                } catch (error) {
                    console.error(`Erro no turno ${turn + 1}:`, error);
                    turn++;
                    setTimeout(executeTurn, 2000);
                }
            }
            
            executeTurn();
        }

        function displayResults() {
            const resultsDiv = document.getElementById('test-results');
            let html = '<h3>Resultados dos Testes de Dano em √Årea:</h3>';
            
            const passed = testResults.filter(t => t.type === 'success').length;
            const total = testResults.length;
            
            html += `<div class="test-result ${total === passed ? 'passed' : 'failed'}">
                <strong>Total: ${passed}/${total} testes passaram</strong>
            </div>`;
            
            testResults.forEach(test => {
                const className = test.type === 'success' ? 'success' : 'error';
                html += `<div class="test-result ${test.type === 'success' ? 'passed' : 'failed'}">
                    <span class="${className}"><strong>${test.name}</strong>: ${test.result}</span><br>
                    <em>${test.details}</em>
                </div>`;
            });
            
            resultsDiv.innerHTML = html;
        }

        // Inicializa√ß√£o
        window.onload = function() {
            console.log('Sistema de Dano em √Årea carregado!');
        };
    </script>
</body>
</html>